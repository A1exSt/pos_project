/*
 * ============================================================================
 * COPYRIGHT
 *              Pax CORPORATION PROPRIETARY INFORMATION
 *   This software is supplied under the terms of a license agreement or
 *   nondisclosure agreement with Pax Corporation and may not be copied
 *   or disclosed except in accordance with the terms in that agreement.
 *      Copyright (C) 2016 Pax Corporation. All rights reserved.
 * Module Date:2016/10/08    
 * Module Auth:huangwp     
 * Description:emv xml file operarte module

 *      
 * ============================================================================
 */

#include "..\inc\global.h"

static int giAidIndex = 0;
static int giCapkIndex = 0;
static int giIcsIndex = 0;
static int giRevokeIndex = 0;
static int giTermInfoIndex = 0;
static int giCurrentOffset = 0;


static NODE_RECORD_T stNoeRecord[] = 
{
		{"AID",0,0},
		{"CAPK",0,0},
		{"ICS",0,0},
		{"REVOKEDCERTIFICATE",0,0},
		{"TERMINALCONFIGURATION",0,0},
};

static int GetRecordIndex(const uchar *pucNodeName, int iSize)
{
	int i = 0;

	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("GetRecordIndex iSize = %d\n", iSize);
	#endif

	for(i = 0; i < iSize; i++)
	{
		if(strcmp(pucNodeName, stNoeRecord[i].ucListNodeName) == 0)
		{
			//ComDebugTx("FindFunctionIndex i = %d\n", i);
			//ComDebugTx("FindFunctionIndex vParseNodeFuncTab[i].iLen = %d\n", vParseListFuncTab[i].iLen);
			//memset(vParseListFuncTab[i].pOutData, 0, vParseListFuncTab[i].iLen);
			//return vParseListFuncTab[i].vFunc(pucXmlOneLine, vParseListFuncTab[i].pOutData);
			return i;
		}
	}
	return EMV_XML_FILE_OP_ERR_RECORD_NOT_FOUNTD;
}

int SaveParsedDataToFile(const uchar *pucFileName, const uchar *pucInData, int iDataSize, int iOffset)
{
	int iFd = 0;
	int iLseek = 0;
	int iRet = 0;
	int iFileSize = 0;
	EMV_AID_NODE_T stAidNode = {0};
	int i = 0;
	
	iFd = PdkFile_Open(pucFileName);
	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("SaveParsedDataToFile PdkFile_Open iFd = %d\n", iFd);
	#endif
	if(iFd < 0)
	{
		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("SaveParsedDataToFile PdkFile_Open fail iFd  = %d\n", iFd);
		#endif
	}

	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("SaveParsedDataToFile  iOffset = %d\n", iOffset);
	#endif

	iFileSize = PdkFile_GetSize(pucFileName);
	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("SaveParsedDataToFile PdkFile_GetSize iFileSize = %d\n", iFileSize);
	#endif
	if(iFileSize < 0)
	{
		PdkFile_Close(iFd);
		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("SaveParsedDataToFile PdkFile_GetSize iFileSize = %d\n", iFileSize);
		#endif
		return iFileSize;
	}

	iLseek = PdkFile_Seek (iFd, iOffset, SEEK_SET);
	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("SaveParsedDataToFile PdkFile_Seek iPos PdkFile_Seek = %d\n", iLseek);
	#endif
	if(iLseek < 0)
	{
		PdkFile_Close(iFd);
		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("SaveParsedDataToFile PdkFile_Seek PdkFile_Seek = %d\n", iLseek);
		#endif
		return iLseek;
	}
	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("SaveParsedDataToFile iDataSize = %d\n", iDataSize);
	#endif

	iRet = PdkFile_Write (iFd, pucInData, iDataSize);
	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("SaveParsedDataToFile PdkFile_Write PdkFile_Write = %d\n", iRet);
	#endif
	if(iRet < 0)
	{
		PdkFile_Close(iFd);
		return iRet;
	}
    
	iFileSize = PdkFile_GetSize(pucFileName);
	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("SaveParsedDataToFile PdkFile_GetSize ------------ iFileSize = %d\n", iFileSize);
	#endif
	if(iFileSize < 0)
	{
		PdkFile_Close(iFd);
		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("SaveParsedDataToFile PdkFile_GetSize ------------iFileSize = %d\n", iFileSize);
		#endif
		return iFileSize;
	}
	
	PdkFile_Close(iFd);
	return iRet;
	
}


static int GetRecordData(NODE_RECORD_T *pststRecord, int iLen)
{
	int iFd = 0;
	int iFileSize = 0;
	int iHavaReadLen = 0;
	int iRet = 0;
	int i = 0;
	
	iFd = PdkFile_Open(EMV_XML_FILE_HAVE_PARSED);
	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("GetRecordData PdkFile_Open iFd = %d\n", iFd);
	#endif
	if(iFd < 0)
	{
		return iFd;
	}

	iFileSize = PdkFile_GetSize(EMV_XML_FILE_HAVE_PARSED);

	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("GetRecordData PdkFile_GetSize iFileSize = %d\n", iFileSize);
	#endif
	if(iFileSize < 0)
	{
		PdkFile_Close(iFd);
		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("GetRecordData PdkFile_GetSize iFileSize = %d\n", iFileSize);
		#endif
		return iFileSize;
	}

	while(iHavaReadLen < iLen)
	{
		memset(pststRecord, 0, iLen);
		iRet = PdkFile_Read(iFd, (uchar*)pststRecord, iLen);

		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("GetRecordData PdkFile_Read iRet = %d\n", iRet);
		#endif
		iHavaReadLen += iRet;
		if(iRet < 0)
		{
			PdkFile_Close(iFd);
			#ifdef EMV_XML_FILE_OP_DEBUG
			ComDebugTx("GetRecordData PdkFile_Read iRet = %d\n", iRet);
			#endif
			return iRet;
		}
	}
	for(i = 0 ; i < EMV_PRASED_NODE_CNT; i++ )
	{
		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("GetRecordData stRecord[%d] = %d\n",i,pststRecord[i].count);
		ComDebugTx("GetRecordData stRecord[%d] = %s\n",i,pststRecord[i].ucListNodeName);
		ComDebugTx("GetRecordData iStartPos[%d] = %d\n",i,pststRecord[i].iStartPos);
		#endif
	}
	PdkFile_Close(iFd);
	return 0;
}

#if 0
static int GetAidData(void)
{
	int iFd = 0;
	int iFileSize = 0;
	int iHavaReadLen = 0;
	int iRet = 0;
	int i = 0;
	int iBaseOffset = 0;
	int iOffset = 0;
	int iIndex = 0;

	NODE_RECORD_T stRecord[EMV_PRASED_NODE_CNT] = {0};
	EMV_AID_NODE_T stAidNode = {0};

	//iBaseOffset = sizeof(stRecord);

	GetRecordData(&stRecord, sizeof(stRecord));

	iIndex = GetRecordIndex("AID", sizeof(stNoeRecord)/sizeof(stNoeRecord[0]));

	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("GetAidData GetRecordIndex iIndex = %d \n", iIndex);
	#endif
	if(iIndex < 0)
	{
		return iIndex;
	}

	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("GetAidData GetRecordData stRecord[%d].iStartPos = %d\n",iIndex,stRecord[iIndex].iStartPos);
	ComDebugTx("GetAidData GetRecordData stRecord[%d].count = %d\n",iIndex,stRecord[iIndex].count);
	ComDebugTx("GetAidData GetRecordData stRecord[%d].ucListNodeName = %s\n",iIndex,stRecord[iIndex].ucListNodeName);
	#endif
	
	iFd = PdkFile_Open(EMV_XML_FILE_HAVE_PARSED);

	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("GetAidData PdkFile_Open iFd = %d\n", iFd);
	#endif
	if(iFd < 0)
	{
		return iFd;
	}

	iFileSize = PdkFile_GetSize(EMV_XML_FILE_HAVE_PARSED);

	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("GetAidData PdkFile_GetSize iFileSize = %d\n", iFileSize);
	#endif
	if(iFileSize < 0)
	{
		PdkFile_Close(iFd);
		ComDebugTx("GetAidData PdkFile_GetSize iFileSize = %d\n", iFileSize);
		return iFileSize;
	}

	//iRet = PdkFile_Seek (iFd, iBaseOffset, SEEK_CUR);
	iRet = PdkFile_Seek (iFd, stRecord[iIndex].iStartPos, SEEK_SET);

	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("GetAidData PdkFile_Seek iPos PdkFile_Seek = %d\n", iRet);
	#endif
	if(iRet < 0)
	{
		PdkFile_Close(iFd);
		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("GetAidData PdkFile_Seek PdkFile_Seek = %d\n", iRet);
		#endif
		return iRet;
	} 	
	
	for(i = 0 ; i < stRecord[iIndex].count; i++ )
	{
		memset(&stAidNode, 0, sizeof(stAidNode));
		iRet = PdkFile_Read(iFd, &stAidNode, sizeof(stAidNode));

		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("GetAidData PdkFile_Read iRet = %d\n", iRet);
		#endif
		iHavaReadLen += iRet;
		if(iRet < 0)
		{
			PdkFile_Close(iFd);
			#ifdef EMV_XML_FILE_OP_DEBUG
			ComDebugTx("GetAidData PdkFile_Read iRet = %d\n", iRet);
			#endif
			return iRet;
		}

		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("GetAidData---- stAidNode[%d].SelFlag = %d \n", i,stAidNode.SelFlag);
		AppHexLog("GetAidData---- stAidNode.AID = \n", stAidNode.AID, sizeof(stAidNode.AID));
		ComDebugTx("GetAidData---- stAidNode[%d].IfUseLocalName = %d \n",  i,stAidNode.IfUseLocalName);
		ComDebugTx("GetAidData---- stAidNode[%d].AppName = %s \n",  i,stAidNode.AppName);
		AppHexLog("GetAidData---- stAidNode.Version = \n", stAidNode.Version, sizeof(stAidNode.Version));
		AppHexLog("GetAidData---- stAidNode.TACDenial  \n", stAidNode.TACDenial, sizeof(stAidNode.TACDenial));
		AppHexLog("GetAidData---- stAidNode .TACOnline = \n",  stAidNode.TACOnline, sizeof(stAidNode.TACOnline));
		AppHexLog("GetAidData---- stAidNode.TACDefault = \n",  stAidNode.TACDefault, sizeof(stAidNode.TACDefault));
		ComDebugTx("GetAidData---- stAidNode[%d].FloorLimit = %d \n",  i,stAidNode.FloorLimit);
		ComDebugTx("GetAidData---- stAidNode[%d].TargetPer = %d \n",  i,stAidNode.TargetPer);
		ComDebugTx("GetAidData---- stAidNode[%d].MaxTargetPer = %d \n",  i,stAidNode.MaxTargetPer);
		AppHexLog("GetAidData---- stAidNode.tDOL = \n",  stAidNode.tDOL, sizeof(stAidNode.tDOL));
		AppHexLog("GetAidData---- stAidNode.dDOL = \n",  stAidNode.dDOL, sizeof(stAidNode.dDOL));
		AppHexLog("GetAidData---- stAidNode.RiskManData = \n", stAidNode.RiskManData, sizeof(stAidNode.RiskManData));
		#endif

		//iRet = PdkFile_Seek (iFd, (i+1)*sizeof(stAidNode), SEEK_SET);

		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("GetAidData PdkFile_Seek iPos PdkFile_Seek = %d\n", iRet);
		#endif
		if(iRet < 0)
		{
			PdkFile_Close(iFd);
			#ifdef EMV_XML_FILE_OP_DEBUG
			ComDebugTx("GetAidData PdkFile_Seek PdkFile_Seek = %d\n", iRet);
			#endif
			return iRet;
		} 
		
	}
	PdkFile_Close(iFd);

	return 0;
}


static int GetCapkData(void)
{
	int iFd = 0;
	int iFileSize = 0;
	int iHavaReadLen = 0;
	int iRet = 0;
	int i = 0;
	int iBaseOffset = 0;
	int iOffset = 0;
	int iIndex = 0;

	NODE_RECORD_T stRecord[EMV_PRASED_NODE_CNT] = {0};
	EMV_CAPK stCapkNode = {0};

	iBaseOffset = sizeof(stRecord);

	GetRecordData(&stRecord, sizeof(stRecord));
	
    iIndex = GetRecordIndex("CAPK", sizeof(stNoeRecord)/sizeof(stNoeRecord[0]));

	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("GetAidData GetRecordIndex iRet = %d \n", iIndex);
	#endif
	if(iIndex < 0)
	{
		return iIndex;
	}
	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("GetCapkData GetRecordData stRecord[%d].iStartPos = %d\n",iIndex,stRecord[iIndex].iStartPos);
	ComDebugTx("GetCapkData GetRecordData stRecord[%d].count = %d\n",iIndex,stRecord[iIndex].count);
	ComDebugTx("GetCapkData GetRecordData stRecord[%d].ucListNodeName = %s\n",iIndex,stRecord[iIndex].ucListNodeName);
	#endif
 
	iFd = PdkFile_Open(EMV_XML_FILE_HAVE_PARSED);

	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("GetCapkData PdkFile_Open iFd = %d\n", iFd);
	#endif
	if(iFd < 0)
	{
		return iFd;
	}

	iFileSize = PdkFile_GetSize(EMV_XML_FILE_HAVE_PARSED);

	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("GetCapkData PdkFile_GetSize iFileSize = %d\n", iFileSize);
	#endif
	if(iFileSize < 0)
	{
		PdkFile_Close(iFd);
		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("GetCapkData PdkFile_GetSize iFileSize = %d\n", iFileSize);
		#endif
		return iFileSize;
	}

	//iRet = PdkFile_Seek (iFd, iBaseOffset, SEEK_CUR);
	iRet = PdkFile_Seek (iFd, stRecord[iIndex].iStartPos, SEEK_SET);

	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("GetCapkData PdkFile_Seek iPos PdkFile_Seek = %d\n", iRet);
	#endif
	if(iRet < 0)
	{
		PdkFile_Close(iFd);
		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("GetCapkData PdkFile_Seek PdkFile_Seek = %d\n", iRet);
		#endif
		return iRet;
	} 
		
	for(i = 0 ; i < stRecord[iIndex].count; i++ )
	{
		memset(&stCapkNode, 0, sizeof(stCapkNode));
		iRet = PdkFile_Read(iFd, &stCapkNode, sizeof(stCapkNode));

		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("GetCapkData PdkFile_Read iRet = %d\n", iRet);
		#endif
		iHavaReadLen += iRet;
		if(iRet < 0)
		{
			PdkFile_Close(iFd);
			#ifdef EMV_XML_FILE_OP_DEBUG
			ComDebugTx("GetCapkData PdkFile_Read iRet = %d\n", iRet);
			#endif
			return iRet;
		}

		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("GetCapkData---- iiiiii = %d \n", i);
		AppHexLog("GetCapkData---- stCapkNode.RID =\n", stCapkNode.RID, sizeof(stCapkNode.RID));
		AppHexLog("GetCapkData---- stCapkNode.KeyID =\n", &(stCapkNode.KeyID), sizeof(stCapkNode.KeyID));
		ComDebugTx("GetCapkData---- stCapkNode.HashInd = %d \n", stCapkNode.HashInd);
		ComDebugTx("GetCapkData---- stCapkNode.ArithInd = %d \n", stCapkNode.ArithInd);
		ComDebugTx("GetCapkData---- stCapkNode.ModulLen = %d \n", stCapkNode.ModulLen);
		AppHexLog("GetCapkData---- stCapkNode.Modul =\n", stCapkNode.Modul, sizeof(stCapkNode.Modul));
		ComDebugTx("GetCapkData---- stCapkNode.ExponentLen = %d \n", stCapkNode.ExponentLen);
		AppHexLog("GetCapkData---- stCapkNode.Exponent = \n", stCapkNode.Exponent, sizeof(stCapkNode.Exponent));
		AppHexLog("GetCapkData---- stCapkNode.ExpDate = \n", stCapkNode.ExpDate, sizeof(stCapkNode.ExpDate));
		AppHexLog("GetCapkData---- stCapkNode.CheckSum = \n", stCapkNode.CheckSum, sizeof(stCapkNode.CheckSum));
		

		//iRet = PdkFile_Seek (iFd, iBaseOffset+(i+1)*sizeof(stCapkNode), SEEK_SET);
		ComDebugTx("GetCapkData PdkFile_Seek iPos PdkFile_Seek = %d\n", iRet);
		#endif
		
		if(iRet < 0)
		{
			PdkFile_Close(iFd);
			#ifdef EMV_XML_FILE_OP_DEBUG
			ComDebugTx("GetCapkData PdkFile_Seek PdkFile_Seek = %d\n", iRet);
			#endif
			return iRet;
		} 
	
	}
	PdkFile_Close(iFd);

	return 0;
}


static int GetIcsData(void)
{
	int iFd = 0;
	int iFileSize = 0;
	int iHavaReadLen = 0;
	int iRet = 0;
	int i = 0;
	int iBaseOffset = 0;
	int iOffset = 0;
	int iIndex = 0;

	NODE_RECORD_T stRecord[EMV_PRASED_NODE_CNT] = {0};
	EMV_ICS_NODE_T stIcsNode = {0};

	iBaseOffset = sizeof(stRecord);

	GetRecordData(&stRecord, sizeof(stRecord));

	iIndex = GetRecordIndex("ICS", sizeof(stNoeRecord)/sizeof(stNoeRecord[0]));

	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("GetIcsData GetRecordIndex iRet = %d \n", iIndex);
	#endif
	if(iIndex < 0)
	{
		return iIndex;
	}

	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("GetIcsData GetRecordData stRecord[%d].iStartPos = %d\n",iIndex,stRecord[iIndex].iStartPos);
	ComDebugTx("GetIcsData GetRecordData stRecord[%d].count = %d\n",iIndex,stRecord[iIndex].count);
	ComDebugTx("GetIcsData GetRecordData stRecord[%d].ucListNodeName = %s\n",iIndex,stRecord[iIndex].ucListNodeName);
	#endif
 
 
	iFd = PdkFile_Open(EMV_XML_FILE_HAVE_PARSED);

	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("GetIcsData PdkFile_Open iFd = %d\n", iFd);
	#endif
	if(iFd < 0)
	{
		return iFd;
	}

	iFileSize = PdkFile_GetSize(EMV_XML_FILE_HAVE_PARSED);

	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("GetIcsData PdkFile_GetSize iFileSize = %d\n", iFileSize);
	#endif
	if(iFileSize < 0)
	{
		PdkFile_Close(iFd);
		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("GetIcsData PdkFile_GetSize iFileSize = %d\n", iFileSize);
		#endif
		return iFileSize;
	}

	//iRet = PdkFile_Seek (iFd, iBaseOffset, SEEK_CUR);
	iRet = PdkFile_Seek (iFd, stRecord[iIndex].iStartPos, SEEK_SET);

	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("GetIcsData PdkFile_Seek iPos PdkFile_Seek = %d\n", iRet);
	#endif
	if(iRet < 0)
	{
		PdkFile_Close(iFd);
		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("GetIcsData PdkFile_Seek PdkFile_Seek = %d\n", iRet);
		#endif
		return iRet;
	} 
		
	for(i = 0 ; i < stRecord[iIndex].count; i++ )
	{
		memset(&stIcsNode, 0, sizeof(stIcsNode));
		iRet = PdkFile_Read(iFd, &stIcsNode, sizeof(stIcsNode));

		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("GetIcsData PdkFile_Read iRet = %d\n", iRet);
		#endif
		iHavaReadLen += iRet;
		if(iRet < 0)
		{
			PdkFile_Close(iFd);
			#ifdef EMV_XML_FILE_OP_DEBUG
			ComDebugTx("GetIcsData PdkFile_Read iRet = %d\n", iRet);
			#endif
			return iRet;
		}

		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("GetIcsData---- iiiiii = %d \n", i);
		ComDebugTx("GetIcsData---- stIcsNode.Type = %s\n", stIcsNode.Type);
		AppHexLog("GetIcsData---- stIcsNode.TerminalType = \n", &(stIcsNode.TerminalType), sizeof(stIcsNode.TerminalType));
		AppHexLog("GetIcsData---- stIcsNode.CardDataInputCapability = \n", &(stIcsNode.CardDataInputCapability), sizeof(stIcsNode.CardDataInputCapability));
		AppHexLog("GetIcsData---- stIcsNode.CVMCapability = \n", &(stIcsNode.CVMCapability), sizeof(stIcsNode.CVMCapability));
		AppHexLog("GetIcsData---- stIcsNode.SecurityCapability = \n", &(stIcsNode.SecurityCapability), sizeof(stIcsNode.SecurityCapability));
		AppHexLog("GetIcsData---- stIcsNode.AdditionalTerminalCapabilities =\n", stIcsNode.AdditionalTerminalCapabilities, sizeof(stIcsNode.AdditionalTerminalCapabilities));
		ComDebugTx("GetIcsData---- stIcsNode.GetDataForPINTryCounter = %d \n", stIcsNode.GetDataForPINTryCounter);
		ComDebugTx("GetIcsData---- stIcsNode.BypassPINEntry = %d \n", stIcsNode.BypassPINEntry);
		ComDebugTx("GetIcsData---- stIcsNode.SubsequentBypassPINEntry = %d \n", stIcsNode.SubsequentBypassPINEntry);
		ComDebugTx("GetIcsData---- stIcsNode.ExceptionFileSupported = %d \n", stIcsNode.ExceptionFileSupported);
		ComDebugTx("GetIcsData---- stIcsNode.ForcedOnlineCapability = %d \n", stIcsNode.ForcedOnlineCapability);
		ComDebugTx("GetIcsData---- stIcsNode.IssuerReferralsSupported = %d \n", stIcsNode.IssuerReferralsSupported);
		AppHexLog("GetIcsData---- stIcsNode.ConfigurationCheckSum = \n", stIcsNode.ConfigurationCheckSum, sizeof(stIcsNode.ConfigurationCheckSum));

		//iRet = PdkFile_Seek (iFd, (i+1)*sizeof(stIcsNode), SEEK_SET);
		ComDebugTx("GetIcsData PdkFile_Seek iPos PdkFile_Seek = %d\n", iRet);
		#endif
		
		if(iRet < 0)
		{
			PdkFile_Close(iFd);
			#ifdef EMV_XML_FILE_OP_DEBUG
			ComDebugTx("GetIcsData PdkFile_Seek PdkFile_Seek = %d\n", iRet);
			#endif
			return iRet;
		} 
		
	}
	PdkFile_Close(iFd);

	return 0;
}


static int GetRevokeData(void)
{
	int iFd = 0;
	int iFileSize = 0;
	int iHavaReadLen = 0;
	int iRet = 0;
	int i = 0;
	int iBaseOffset = 0;
	int iOffset = 0;
	int iIndex = 0;

	NODE_RECORD_T stRecord[EMV_PRASED_NODE_CNT] = {0};
	EMV_REVOCLIST stRevokeNode = {0};

	iBaseOffset = sizeof(stRecord);

	GetRecordData(&stRecord, sizeof(stRecord));

	iIndex = GetRecordIndex("REVOKEDCERTIFICATE", sizeof(stNoeRecord)/sizeof(stNoeRecord[0]));

	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("GetRevokeData GetRecordIndex iRet = %d \n", iIndex);
	#endif
	if(iIndex < 0)
	{
		return iIndex;
	}

	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("GetRevokeData GetRecordData stRecord[%d].iStartPos = %d\n",iIndex,stRecord[iIndex].iStartPos);
	ComDebugTx("GetRevokeData GetRecordData stRecord[%d].count = %d\n",iIndex,stRecord[iIndex].count);
	ComDebugTx("GetRevokeData GetRecordData stRecord[%d].ucListNodeName = %s\n",iIndex,stRecord[iIndex].ucListNodeName);
	#endif
 
	iFd = PdkFile_Open(EMV_XML_FILE_HAVE_PARSED);

	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("GetRevokeData PdkFile_Open iFd = %d\n", iFd);
	#endif
	if(iFd < 0)
	{
		return iFd;
	}

	iFileSize = PdkFile_GetSize(EMV_XML_FILE_HAVE_PARSED);

	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("GetRevokeData PdkFile_GetSize iFileSize = %d\n", iFileSize);
	#endif
	if(iFileSize < 0)
	{
		PdkFile_Close(iFd);
		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("GetRevokeData PdkFile_GetSize iFileSize = %d\n", iFileSize);
		#endif
		return iFileSize;
	}

	//iRet = PdkFile_Seek (iFd, iBaseOffset, SEEK_CUR);
	iRet = PdkFile_Seek (iFd, stRecord[iIndex].iStartPos, SEEK_SET);

	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("GetRevokeData PdkFile_Seek iPos PdkFile_Seek = %d\n", iRet);
	#endif
	if(iRet < 0)
	{
		PdkFile_Close(iFd);
		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("GetRevokeData PdkFile_Seek PdkFile_Seek = %d\n", iRet);
		#endif
		return iRet;
	} 
		
	for(i = 0 ; i < stRecord[iIndex].count; i++ )
	{
		memset(&stRevokeNode, 0, sizeof(stRevokeNode));
		iRet = PdkFile_Read(iFd, &stRevokeNode, sizeof(stRevokeNode));

		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("GetRevokeData PdkFile_Read iRet = %d\n", iRet);
		#endif
		iHavaReadLen += iRet;
		if(iRet < 0)
		{
			PdkFile_Close(iFd);
			#ifdef EMV_XML_FILE_OP_DEBUG
			ComDebugTx("GetRevokeData PdkFile_Read iRet = %d\n", iRet);
			#endif
			return iRet;
		}

		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("GetRevokeData---- iiiiii = %d \n", i);
		AppHexLog("GetRevokeData---- stRevokeNode.ucRid = \n", stRevokeNode.ucRid, sizeof(stRevokeNode.ucRid));
		//ComDebugTx("ParseRevokeCertificateList---- stRevokeNode.ucIndex = %d\n", stRevokeNode->ucIndex);
		AppHexLog("GetRevokeData---- stRevokeNode.ucIndex = \n", &(stRevokeNode.ucIndex), sizeof(stRevokeNode.ucIndex));
		AppHexLog("GetRevokeData---- stRevokeNode.ucCertSn = \n", stRevokeNode.ucCertSn, sizeof(stRevokeNode.ucCertSn));
		//iRet = PdkFile_Seek (iFd, iBaseOffset+(i+1)*sizeof(stRevokeNode), SEEK_SET);
		ComDebugTx("GetRevokeData PdkFile_Seek iPos PdkFile_Seek = %d\n", iRet);
		#endif
		
		if(iRet < 0)
		{
			PdkFile_Close(iFd);
			#ifdef EMV_XML_FILE_OP_DEBUG
			ComDebugTx("GetRevokeData PdkFile_Seek PdkFile_Seek = %d\n", iRet);
			#endif
			return iRet;
		} 
		
	}
	PdkFile_Close(iFd);

	return 0;
}


static int GetTermInfoData(void)
{
	int iFd = 0;
	int iFileSize = 0;
	int iHavaReadLen = 0;
	int iRet = 0;
	int i = 0;
	int iBaseOffset = 0;
	int iOffset = 0;
	int iIndex = 0;

	NODE_RECORD_T stRecord[EMV_PRASED_NODE_CNT] = {0};
	EMV_TERMINALINFO_NODE_T stTermInfoNode = {0};

	iBaseOffset = sizeof(stRecord);

	GetRecordData(&stRecord, sizeof(stRecord));

	iIndex = GetRecordIndex("TERMINALCONFIGURATION", sizeof(stNoeRecord)/sizeof(stNoeRecord[0]));

	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("GetTermInfoData GetRecordIndex iRet = %d \n", iIndex);
	#endif
	if(iIndex < 0)
	{
		return iIndex;
	}

	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("GetTermInfoData GetRecordData stRecord[%d].iStartPos = %d\n",iIndex,stRecord[iIndex].iStartPos);
	ComDebugTx("GetTermInfoData GetRecordData stRecord[%d].count = %d\n",iIndex,stRecord[iIndex].count);
	ComDebugTx("GetTermInfoData GetRecordData stRecord[%d].ucListNodeName = %s\n",iIndex,stRecord[iIndex].ucListNodeName);
	#endif
	
	iFd = PdkFile_Open(EMV_XML_FILE_HAVE_PARSED);

	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("GetTermInfoData PdkFile_Open iFd = %d\n", iFd);
	#endif
	if(iFd < 0)
	{
		return iFd;
	}

	iFileSize = PdkFile_GetSize(EMV_XML_FILE_HAVE_PARSED);

	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("GetTermInfoData PdkFile_GetSize iFileSize = %d\n", iFileSize);
	#endif
	if(iFileSize < 0)
	{
		PdkFile_Close(iFd);
		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("GetTermInfoData PdkFile_GetSize iFileSize = %d\n", iFileSize);
		#endif
		return iFileSize;
	}

	//iRet = PdkFile_Seek (iFd, iBaseOffset, SEEK_CUR);
	iRet = PdkFile_Seek (iFd, stRecord[iIndex].iStartPos, SEEK_SET);

	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("GetTermInfoData PdkFile_Seek iPos PdkFile_Seek = %d\n", iRet);
	#endif
	if(iRet < 0)
	{
		PdkFile_Close(iFd);
		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("GetTermInfoData PdkFile_Seek PdkFile_Seek = %d\n", iRet);
		#endif
		return iRet;
	} 
		
	for(i = 0 ; i < stRecord[iIndex].count; i++ )
	{
		memset(&stTermInfoNode, 0, sizeof(stTermInfoNode));
		iRet = PdkFile_Read(iFd, &stTermInfoNode, sizeof(stTermInfoNode));

		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("GetTermInfoData PdkFile_Read iRet = %d\n", iRet);
		#endif
		iHavaReadLen += iRet;
		if(iRet < 0)
		{
			PdkFile_Close(iFd);
			#ifdef EMV_XML_FILE_OP_DEBUG
			ComDebugTx("GetTermInfoData PdkFile_Read iRet = %d\n", iRet);
			#endif
			return iRet;
		}

		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("GetTermInfoData---- iiiiii = %d \n", i);
		ComDebugTx("GetTermInfoData---- ParseTerminalInfoList.aucMerchName = %s\n", stTermInfoNode.aucMerchName);
		ComDebugTx("GetTermInfoData---- ParseTerminalInfoList.aucMerchantLocation = %s\n", stTermInfoNode.aucMerchantLocation);
		ComDebugTx("GetTermInfoData---- ParseTerminalInfoList.aucMerchId = %s\n", stTermInfoNode.aucMerchId);
		ComDebugTx("GetTermInfoData---- ParseTerminalInfoList.aucTermId = %s\n", stTermInfoNode.aucTermId);
		AppHexLog("GetTermInfoData----  ParseTerminalInfoList.aucCountryCode = \n", stTermInfoNode.aucCountryCode, sizeof(stTermInfoNode.aucCountryCode));
		AppHexLog("GetTermInfoData----  ParseTerminalInfoList.aucTransCurrCode =\n", stTermInfoNode.aucTransCurrCode, sizeof(stTermInfoNode.aucTransCurrCode));
		AppHexLog("GetTermInfoData---- ParseTerminalInfoList.aucReferCurrCode = \n", stTermInfoNode.aucReferCurrCode, sizeof(stTermInfoNode.aucReferCurrCode));
		AppHexLog("GetTermInfoData---- ParseTerminalInfoList.aucMerchCateCode = \n", stTermInfoNode.aucMerchCateCode, sizeof(stTermInfoNode.aucMerchCateCode));
		ComDebugTx("GetTermInfoData---- ParseTerminalInfoList.ucTerminalCurrencyExponent = %d \n", stTermInfoNode.ucTerminalCurrencyExponent);
		ComDebugTx("GetTermInfoData---- ParseTerminalInfoList.ucReferenceCurrencyExponent = %d \n", stTermInfoNode.ucReferenceCurrencyExponent);
		ComDebugTx("GetTermInfoData---- ParseTerminalInfoList.ucConversionRatio = %d \n", stTermInfoNode.ucConversionRatio);

		//iRet = PdkFile_Seek (iFd, iBaseOffset+(i+1)*sizeof(stIcsNode), SEEK_SET);
		ComDebugTx("GetTermInfoData PdkFile_Seek iPos PdkFile_Seek = %d\n", iRet);
		#endif
		
		if(iRet < 0)
		{
			PdkFile_Close(iFd);
			#ifdef EMV_XML_FILE_OP_DEBUG
			ComDebugTx("GetTermInfoData PdkFile_Seek PdkFile_Seek = %d\n", iRet);
			#endif
			return iRet;
		} 	
	}
	PdkFile_Close(iFd);

	return 0;
}
#endif


static int PrintNodeStruct(const uchar *pucNodeName, void *data, int iLen)
{
	int iOffset = 0;
	int iBaseOffset = 0;
	//NODE_RECORD_T stRecord[EMV_PRASED_NODE_CNT] = {0};
	int iRet = 0;
	int iSaveLen = 0;

	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("PrintNodeStruct---- iBaseOffset = %d \n", iBaseOffset);
	#endif

	if(strcmp(pucNodeName, "<AID>") == 0)
	{
		EMV_AID_NODE_T *stAidNode = NULL;
		stAidNode = (EMV_AID_NODE_T *)data;
		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("ParseAidList---- stAidNode.SelFlag = %d \n", stAidNode->SelFlag);
		AppHexLog("ParseAidList---- stAidNode.AID = \n", stAidNode->AID, sizeof(stAidNode->AID));
		ComDebugTx("ParseAidList---- stAidNode.IfUseLocalName = %d \n", stAidNode->IfUseLocalName);
		ComDebugTx("ParseAidList---- stAidNode.AppName = %s \n", stAidNode->AppName);
		AppHexLog("ParseAidList---- stAidNode.Version = \n", stAidNode->Version, sizeof(stAidNode->Version));
		AppHexLog("ParseAidList---- stAidNode.TACDenial  \n", stAidNode->TACDenial, sizeof(stAidNode->TACDenial));
		AppHexLog("ParseAidList---- stAidNode.TACOnline = \n", stAidNode->TACOnline, sizeof(stAidNode->TACOnline));
		AppHexLog("ParseAidList---- stAidNode.TACDefault = \n", stAidNode->TACDefault, sizeof(stAidNode->TACDefault));
		ComDebugTx("ParseAidList---- stAidNode.FloorLimit = %d \n", stAidNode->FloorLimit);
		ComDebugTx("ParseAidList---- stAidNode.TargetPer = %d \n", stAidNode->TargetPer);
		ComDebugTx("ParseAidList---- stAidNode.MaxTargetPer = %d \n", stAidNode->MaxTargetPer);
		AppHexLog("ParseAidList---- stAidNode.tDOL = \n", stAidNode->tDOL, sizeof(stAidNode->tDOL));
		AppHexLog("ParseAidList---- stAidNode.dDOL = \n", stAidNode->dDOL, sizeof(stAidNode->dDOL));
		AppHexLog("ParseAidList---- stAidNode.RiskManData = \n", stAidNode->RiskManData, sizeof(stAidNode->RiskManData));
		ComDebugTx("ParseAidList---- giAidIndex = %d \n", giAidIndex);
		
		ComDebugTx("PrintNodeStruct----stAidNode giCurrentOffset = %d \n", giCurrentOffset);
		#endif
		iSaveLen = SaveParsedDataToFile(EMV_XML_FILE_HAVE_PARSED, (uchar*)stAidNode, iLen, giCurrentOffset);
		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("PrintNodeStruct----stAidNode SaveParsedDataToFile iRet = %d \n", iRet);
		#endif
		if(giAidIndex == 0)
		{
			iRet = GetRecordIndex("AID", sizeof(stNoeRecord)/sizeof(stNoeRecord[0]));

			#ifdef EMV_XML_FILE_OP_DEBUG
			ComDebugTx("PrintNodeStruct----stAidNode GetRecordIndex iRet = %d \n", iRet);
			#endif
			stNoeRecord[iRet].iStartPos = giCurrentOffset;
		}
		giCurrentOffset += iSaveLen;
		giAidIndex++;
	}
	else if(strcmp(pucNodeName, "<CAPK>") == 0)
	{
		EMV_CAPK *stCapkNode = NULL;
		stCapkNode = (EMV_CAPK *)data;
		#ifdef EMV_XML_FILE_OP_DEBUG
		AppHexLog("ParseCapkList---- stCapkNode.RID =\n", stCapkNode->RID, sizeof(stCapkNode->RID));
		AppHexLog("ParseCapkList---- stCapkNode.KeyID =\n", &(stCapkNode->KeyID), sizeof(stCapkNode->KeyID));
		ComDebugTx("ParseCapkList---- stCapkNode.HashInd = %d \n", stCapkNode->HashInd);
		ComDebugTx("ParseCapkList---- stCapkNode.ArithInd = %d \n", stCapkNode->ArithInd);
		ComDebugTx("ParseCapkList---- stCapkNode.ModulLen = %d \n", stCapkNode->ModulLen);
		AppHexLog("ParseCapkList---- stCapkNode.Modul =\n", stCapkNode->Modul, sizeof(stCapkNode->Modul));
		ComDebugTx("ParseCapkList---- stCapkNode.ExponentLen = %d \n", stCapkNode->ExponentLen);
		AppHexLog("ParseCapkList---- stCapkNode.Exponent = \n", stCapkNode->Exponent, sizeof(stCapkNode->Exponent));
		AppHexLog("ParseCapkList---- stCapkNode.ExpDate = \n", stCapkNode->ExpDate, sizeof(stCapkNode->ExpDate));
		AppHexLog("ParseCapkList---- stCapkNode.CheckSum = \n", stCapkNode->CheckSum, sizeof(stCapkNode->CheckSum));
		ComDebugTx("ParseCapkList---- iCapkIndex = %d \n", giCapkIndex);
		ComDebugTx("PrintNodeStruct----stCapkNode giCurrentOffset = %d \n", giCurrentOffset);
		#endif
		iSaveLen = SaveParsedDataToFile(EMV_XML_FILE_HAVE_PARSED, (uchar*)stCapkNode, iLen, giCurrentOffset);
		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("PrintNodeStruct----stCapkNode SaveParsedDataToFile iRet = %d \n", iRet);
		#endif
		if(giCapkIndex == 0)
		{
			iRet = GetRecordIndex("CAPK", sizeof(stNoeRecord)/sizeof(stNoeRecord[0]));

			#ifdef EMV_XML_FILE_OP_DEBUG
			ComDebugTx("PrintNodeStruct----stCapkNode GetRecordIndex iRet = %d \n", iRet);
			#endif
			stNoeRecord[iRet].iStartPos = giCurrentOffset;
		}
		giCurrentOffset += iSaveLen;
		giCapkIndex++;
	}
	else if(strcmp(pucNodeName, "<ICS>") == 0)
	{
		EMV_ICS_NODE_T *stIcsNode = NULL;
		stIcsNode = (EMV_ICS_NODE_T *)data;

		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("ParseIcsList---- stIcsNode.Type = %s\n", stIcsNode->Type);
		AppHexLog("ParseIcsList---- stIcsNode.TerminalType = \n", &(stIcsNode->TerminalType), sizeof(stIcsNode->TerminalType));
		AppHexLog("ParseIcsList---- stIcsNode.CardDataInputCapability = \n", &(stIcsNode->CardDataInputCapability), sizeof(stIcsNode->CardDataInputCapability));
		AppHexLog("ParseIcsList---- stIcsNode.CVMCapability = \n", &(stIcsNode->CVMCapability), sizeof(stIcsNode->CVMCapability));
		AppHexLog("ParseIcsList---- stIcsNode.SecurityCapability = \n", &(stIcsNode->SecurityCapability), sizeof(stIcsNode->SecurityCapability));
		AppHexLog("ParseIcsList---- stIcsNode.AdditionalTerminalCapabilities =\n", stIcsNode->AdditionalTerminalCapabilities, sizeof(stIcsNode->AdditionalTerminalCapabilities));
		ComDebugTx("ParseIcsList---- stIcsNode.GetDataForPINTryCounter = %d \n", stIcsNode->GetDataForPINTryCounter);
		ComDebugTx("ParseIcsList---- stIcsNode.BypassPINEntry = %d \n", stIcsNode->BypassPINEntry);
		ComDebugTx("ParseIcsList---- stIcsNode.SubsequentBypassPINEntry = %d \n", stIcsNode->SubsequentBypassPINEntry);
		ComDebugTx("ParseIcsList---- stIcsNode.ExceptionFileSupported = %d \n", stIcsNode->ExceptionFileSupported);
		ComDebugTx("ParseIcsList---- stIcsNode.ForcedOnlineCapability = %d \n", stIcsNode->ForcedOnlineCapability);
		ComDebugTx("ParseIcsList---- stIcsNode.IssuerReferralsSupported = %d \n", stIcsNode->IssuerReferralsSupported);
		AppHexLog("ParseIcsList---- stIcsNode.ConfigurationCheckSum = \n", stIcsNode->ConfigurationCheckSum, sizeof(stIcsNode->ConfigurationCheckSum));
		ComDebugTx("ParseIcsList---- giIcsIndex = %d \n", giIcsIndex);
	    ComDebugTx("PrintNodeStruct----stIcsNode giCurrentOffset = %d \n", giCurrentOffset);
		#endif
		iSaveLen = SaveParsedDataToFile(EMV_XML_FILE_HAVE_PARSED, (uchar*)stIcsNode, iLen, giCurrentOffset);
		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("PrintNodeStruct----stAidNode SaveParsedDataToFile iRet = %d \n", iRet);
		#endif
		if(giIcsIndex == 0)
		{
			iRet = GetRecordIndex("ICS", sizeof(stNoeRecord)/sizeof(stNoeRecord[0]));
			#ifdef EMV_XML_FILE_OP_DEBUG
			ComDebugTx("PrintNodeStruct----stIcsNode GetRecordIndex iRet = %d \n", iRet);
			#endif
			stNoeRecord[iRet].iStartPos = giCurrentOffset;
		}
		giCurrentOffset += iSaveLen;
		giIcsIndex++;
	}
	else if(strcmp(pucNodeName, "<REVOKEDCERTIFICATE>") == 0)
	{
		EMV_REVOCLIST *stRevokeNode = NULL;
		stRevokeNode = (EMV_REVOCLIST *)data;

		#ifdef EMV_XML_FILE_OP_DEBUG
		AppHexLog("ParseRevokeCertificateList---- stRevokeNode.ucRid = \n", stRevokeNode->ucRid, sizeof(stRevokeNode->ucRid));
		//ComDebugTx("ParseRevokeCertificateList---- stRevokeNode.ucIndex = %d\n", stRevokeNode->ucIndex);
		AppHexLog("ParseRevokeCertificateList---- stRevokeNode.ucIndex = \n", &(stRevokeNode->ucIndex), sizeof(stRevokeNode->ucIndex));
		AppHexLog("ParseRevokeCertificateList---- stRevokeNode.ucCertSn = \n", stRevokeNode->ucCertSn, sizeof(stRevokeNode->ucCertSn));
		ComDebugTx("ParseRevokeCertificateList---- giRevokeIndex = %d \n", giRevokeIndex);

		ComDebugTx("PrintNodeStruct----stRevokeNode giCurrentOffset = %d \n", giCurrentOffset);
		#endif
		iSaveLen = SaveParsedDataToFile(EMV_XML_FILE_HAVE_PARSED, (uchar*)stRevokeNode, iLen, giCurrentOffset);
		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("PrintNodeStruct----stRevokeNode SaveParsedDataToFile iRet = %d \n", iRet);
		#endif
		if(giRevokeIndex == 0)
		{
			iRet = GetRecordIndex("REVOKEDCERTIFICATE", sizeof(stNoeRecord)/sizeof(stNoeRecord[0]));
			#ifdef EMV_XML_FILE_OP_DEBUG
			ComDebugTx("PrintNodeStruct----stRevokeNode GetRecordIndex iRet = %d \n", iRet);
			#endif
			stNoeRecord[iRet].iStartPos = giCurrentOffset;
		}
		giCurrentOffset += iSaveLen;
		giRevokeIndex++;
	}
	else if(strcmp(pucNodeName, "<TERMINALCONFIGURATION>") == 0)
	{
		EMV_TERMINALINFO_NODE_T *stTermInfoNode = NULL;
		stTermInfoNode = (EMV_TERMINALINFO_NODE_T *)data;

		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("ParseTerminalInfoList---- ParseTerminalInfoList.aucMerchName = %s\n", stTermInfoNode->aucMerchName);
		ComDebugTx("ParseTerminalInfoList---- ParseTerminalInfoList.aucMerchantLocation = %s\n", stTermInfoNode->aucMerchantLocation);
		ComDebugTx("ParseTerminalInfoList---- ParseTerminalInfoList.aucMerchId = %s\n", stTermInfoNode->aucMerchId);
		ComDebugTx("ParseTerminalInfoList---- ParseTerminalInfoList.aucTermId = %s\n", stTermInfoNode->aucTermId);
		AppHexLog("ParseTerminalInfoList----  ParseTerminalInfoList.aucCountryCode = \n", stTermInfoNode->aucCountryCode, sizeof(stTermInfoNode->aucCountryCode));
		AppHexLog("ParseTerminalInfoList----  ParseTerminalInfoList.aucTransCurrCode =\n", stTermInfoNode->aucTransCurrCode, sizeof(stTermInfoNode->aucTransCurrCode));
		AppHexLog("ParseTerminalInfoList---- ParseTerminalInfoList.aucReferCurrCode = \n", stTermInfoNode->aucReferCurrCode, sizeof(stTermInfoNode->aucReferCurrCode));
		AppHexLog("ParseTerminalInfoList---- ParseTerminalInfoList.aucMerchCateCode = \n", stTermInfoNode->aucMerchCateCode, sizeof(stTermInfoNode->aucMerchCateCode));
		ComDebugTx("ParseTerminalInfoList---- ParseTerminalInfoList.ucTerminalCurrencyExponent = %d \n", stTermInfoNode->ucTerminalCurrencyExponent);
		ComDebugTx("ParseTerminalInfoList---- ParseTerminalInfoList.ucReferenceCurrencyExponent = %d \n", stTermInfoNode->ucReferenceCurrencyExponent);
		ComDebugTx("ParseTerminalInfoList---- ParseTerminalInfoList.ucConversionRatio = %d \n", stTermInfoNode->ucConversionRatio);
		ComDebugTx("ParseTerminalInfoList---- giTermInfoIndex = %d \n", giTermInfoIndex);

		ComDebugTx("PrintNodeStruct----ParseTerminalInfoList giCurrentOffset = %d \n", giCurrentOffset);
		#endif
		iSaveLen = SaveParsedDataToFile(EMV_XML_FILE_HAVE_PARSED, (uchar*)stTermInfoNode, iLen, giCurrentOffset);
		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("PrintNodeStruct----ParseTerminalInfoList SaveParsedDataToFile iRet = %d \n", iRet);
		#endif
		if(giTermInfoIndex == 0)
		{
			iRet = GetRecordIndex("TERMINALCONFIGURATION", sizeof(stNoeRecord)/sizeof(stNoeRecord[0]));
			#ifdef EMV_XML_FILE_OP_DEBUG
			ComDebugTx("PrintNodeStruct----ParseTerminalInfoList GetRecordIndex iRet = %d \n", iRet);
			#endif
			stNoeRecord[iRet].iStartPos = giCurrentOffset;
		}
		giCurrentOffset += iSaveLen;
		giTermInfoIndex++;
	}
	return giCurrentOffset;
}


//begin to parse aid
static int GetAidChileNode(const uchar *pucXmlOneLine)
{
	if(pucXmlOneLine == NULL)
	{
		return EMV_XML_FILE_OP_ERR_INVALID_PARAM;
	}
	if(strstr(pucXmlOneLine, "</AID>") != NULL)
	{
		return EMV_XML_FILE_OP_OK;
	}
		
	if(strstr(pucXmlOneLine, "PartialAIDSelection") != NULL)
	{
		return PARTIALAIDSELECTION;
	}
	if(strstr(pucXmlOneLine, "ApplicationID") != NULL)
	{
		return APPLICATIONID;
	}
	if(strstr(pucXmlOneLine, "IfUseLocalAIDName") != NULL)
	{
		return IFUSELOCALNAME;
	}
	if(strstr(pucXmlOneLine, "LocalAIDName") != NULL)
	{
		return LOACALAIDNAME;
	}
	if(strstr(pucXmlOneLine, "TerminalAIDVersion") != NULL)
	{
		return TERMINALAIDVERSION;
	}
	if(strstr(pucXmlOneLine, "TACDenial") != NULL)
	{
		return TACDENIAL;
	}
	if(strstr(pucXmlOneLine, "TACOnline") != NULL)
	{
		return TACONLINE;
	}
	if(strstr(pucXmlOneLine, "TACDefault") != NULL)
	{
		return TACDEFAULT;
	}
	if(strstr(pucXmlOneLine, "FloorLimit") != NULL)
	{
		return FLOORLIMIT;
	}
	if(strstr(pucXmlOneLine, "Threshold") != NULL)
	{
		return THRESHOLD;
	}
	if(strstr(pucXmlOneLine, "TargetPercentage") != NULL)
	{
		return TARGETPERCENTAGE;
	}
	if(strstr(pucXmlOneLine, "MaxTargetPercentage") != NULL)
	{
		return MAXTARGETPERCENTAGE;
	}
	if(strstr(pucXmlOneLine, "TerminalDefaultTDOL") != NULL)
	{
		return TERMINALDEFAULTTDOL;
	}
	if(strstr(pucXmlOneLine, "TerminalDefaultDDOL") != NULL)
	{
		return TERMINALDEFAULTDDOL;
	}
	if(strstr(pucXmlOneLine, "TerminalRiskManagementData") != NULL)
	{
		return TERMINALRISKMANAGEMENTDATA;
	}
	else
	{
		return EMV_XML_FILE_OP_ERR_INVALID_PARAM;
	}

}

static int GetPartialSelectionValue(const uchar *pucXmlOneLine, uchar *piData)
{
    int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "PartialAIDSelection", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	*piData = (uchar)atoi(pucBuf);
	return iRet;
}

static int GetApplicationIDValue(const uchar *pucXmlOneLine, uchar *pucData)
{
    int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "ApplicationID", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	PubAsc2Bcd(pucBuf, strlen((const char *)pucBuf), pucData);

	return iRet;
}


static int GetIfUseLocalAIDNameValue(const uchar *pucXmlOneLine, int *piData)
{
    int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "IfUseLocalAIDName", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	*piData = atoi(pucBuf);
	return iRet;
}


static int GetLocalAIDNameValue(const uchar *pucXmlOneLine, uchar *pucData)
{
    int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "LocalAIDName", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	//memcpy(pucData, pucBuf, sizeof(pucData));
	//memcpy(pucData, pucBuf, strlen(pucData));
	strcpy(pucData, pucBuf);

	return iRet;
}

static int GetTerminalAIDVersionValue(const uchar *pucXmlOneLine, uchar *pucData)
{
    int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "TerminalAIDVersion", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	PubAsc2Bcd(pucBuf, strlen((const char *)pucBuf), pucData);

	return iRet;
}

static int GetTACDenialValue(const uchar *pucXmlOneLine, uchar *pucData)
{
    int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "TACDenial", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	PubAsc2Bcd(pucBuf, strlen((const char *)pucBuf), pucData);

	return iRet;
}

static int GetTACOnlinelValue(const uchar *pucXmlOneLine, uchar *pucData)
{
    int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "TACOnline", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	PubAsc2Bcd(pucBuf, strlen((const char *)pucBuf), pucData);

	return iRet;
}

static int GetTACDefaultlValue(const uchar *pucXmlOneLine, uchar *pucData)
{
    int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "TACDefault", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	PubAsc2Bcd(pucBuf, strlen((const char *)pucBuf), pucData);

	return iRet;
}

static int GetFloorLimitValue(const uchar *pucXmlOneLine, uint *piData)
{
    int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "FloorLimit", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	*piData = (ulong)atoi(pucBuf);
	return iRet;
}

static int GetThresholdValue(const uchar *pucXmlOneLine, uint *piData)
{
    int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "Threshold", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	*piData = (ulong)atoi(pucBuf);
	return iRet;
}

static int GetTargetPercentageValue(const uchar *pucXmlOneLine, uchar *piData)
{
    int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "TargetPercentage", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	*piData = (uchar)atoi(pucBuf);
	return iRet;
}

static int GetTerminalDefaultTDOLValue(const uchar *pucXmlOneLine, uchar *pucData)
{
    int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "TerminalDefaultTDOL", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	PubAsc2Bcd(pucBuf, strlen((const char *)pucBuf), pucData);

	return iRet;
}

static int GetMaxTargetPercentageValue(const uchar *pucXmlOneLine, uchar *piData)
{
    int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "MaxTargetPercentage", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	*piData = (uchar)atoi(pucBuf);
	return iRet;
}

static int GetTerminalDefaultDDOLlValue(const uchar *pucXmlOneLine, uchar *pucData)
{
    int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "TerminalDefaultDDOL", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	PubAsc2Bcd(pucBuf, strlen((const char *)pucBuf), pucData);

	return iRet;
}

static int GetTerminalRiskManagementDataValue(const uchar *pucXmlOneLine, uchar *pucData)
{
    int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "TerminalRiskManagementData", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	PubAsc2Bcd(pucBuf, strlen((const char *)pucBuf), pucData);

	return iRet;
}

//static int ParseEmvAidChildNode(const uchar *pucXmlOneLine, EMV_AID_NODE_T *pstAidNode)
static int ParseEmvAidChildNode(const uchar *pucXmlOneLine, void *Data)
{
	int iAidChildNode = 0;
	int iRet = 0;
	int iSize = 0;
	int i = 0;
	EMV_AID_NODE_T *stAidNode = NULL;
	stAidNode = (EMV_AID_NODE_T *)Data;

	if(pucXmlOneLine == NULL)
	{
		return EMV_XML_FILE_OP_ERR_INVALID_PARAM;
	}

	iAidChildNode = GetAidChileNode(pucXmlOneLine);
	if(iAidChildNode < 0)
	{
		return EMV_XML_FILE_OP_ERR_NODE_NOT_EXIST;
	}

	switch(iAidChildNode)
	{
		case PARTIALAIDSELECTION:
			iRet = GetPartialSelectionValue(pucXmlOneLine, &(stAidNode->SelFlag));
			break;
		case APPLICATIONID:
			iRet = GetApplicationIDValue(pucXmlOneLine, stAidNode->AID);
			break;
		case IFUSELOCALNAME:
			iRet = GetIfUseLocalAIDNameValue(pucXmlOneLine, &(stAidNode->IfUseLocalName));
			break;
		case LOACALAIDNAME:
			iRet = GetLocalAIDNameValue(pucXmlOneLine, stAidNode->AppName);
			break;
		case TERMINALAIDVERSION:
			iRet = GetTerminalAIDVersionValue(pucXmlOneLine, stAidNode->Version);
			break;
		case TACDENIAL:
			iRet = GetTACDenialValue(pucXmlOneLine, stAidNode->TACDenial);
			break;
		case TACONLINE:
			iRet = GetTACOnlinelValue(pucXmlOneLine, stAidNode->TACOnline);
			break;
		case TACDEFAULT:
			iRet = GetTACDefaultlValue(pucXmlOneLine, stAidNode->TACDefault);
			break;
		case FLOORLIMIT:
			iRet = GetFloorLimitValue(pucXmlOneLine, &(stAidNode->FloorLimit));
			break;
		case THRESHOLD:
			iRet = GetThresholdValue(pucXmlOneLine, &(stAidNode->Threshold));
			break;
		case TARGETPERCENTAGE:
			iRet = GetTargetPercentageValue(pucXmlOneLine, &(stAidNode->TargetPer));
			break;
		case MAXTARGETPERCENTAGE:
			iRet = GetMaxTargetPercentageValue(pucXmlOneLine, &(stAidNode->MaxTargetPer));
			break;
		case TERMINALDEFAULTTDOL:
			iRet = GetTerminalDefaultTDOLValue(pucXmlOneLine, stAidNode->tDOL);
			break;
		case TERMINALDEFAULTDDOL:
			iRet = GetTerminalDefaultDDOLlValue(pucXmlOneLine, stAidNode->dDOL);
			break;

		case TERMINALRISKMANAGEMENTDATA:
			iRet = GetTerminalRiskManagementDataValue(pucXmlOneLine, stAidNode->RiskManData);
			break;

		default:
			break;
	}
	
	
#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("ParseEmvAidChildNode---- GetAidChileNode = %d iSize = %d iRet = %d\n", iAidChildNode, iSize, iRet);
#endif
	
	return iRet;
}



//parse capk

static int GetCapkChileNode(const uchar *pucXmlOneLine)
{
	
	if(pucXmlOneLine == NULL)
	{
		return EMV_XML_FILE_OP_ERR_INVALID_PARAM;
	}
	if(strstr(pucXmlOneLine, "<RID") != NULL)
	{
		return RID;
	}
	if(strstr(pucXmlOneLine, "<KeyID") != NULL)
	{
		return KEYID;
	}
	if(strstr(pucXmlOneLine, "<HashArithmeticIndex") != NULL)
	{
		return HASHARITHMETICINDEX;
	}
	if(strstr(pucXmlOneLine, "<RSAArithmeticIndex") != NULL)
	{
		return RSAARITHMRTICINDEX;
	}
	if(strstr(pucXmlOneLine, "<ModuleLength") != NULL)
	{
		return MODULELENGTH;
	}
	if(strstr(pucXmlOneLine, "<Module") != NULL)
	{
		return MODULE;
	}
	if(strstr(pucXmlOneLine, "<ExponentLength") != NULL)
	{
		return EXPONENTLENGTH;
	}
	if(strstr(pucXmlOneLine, "<Exponent") != NULL)
	{
		return EXPONENT;
	}
	if(strstr(pucXmlOneLine, "<ExpireDate") != NULL)
	{
		return EXPIREDATE;
	}
	if(strstr(pucXmlOneLine, "<CheckSum") != NULL)
	{
		return CHECKSUM;
	}
	else
	{
		return EMV_XML_FILE_OP_ERR_INVALID_PARAM;
	}

}


static int GetRIDValue(const uchar *pucXmlOneLine,  uchar *pucData)
{
    int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "RID", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	PubAsc2Bcd(pucBuf, strlen((const char *)pucBuf), pucData);
	return iRet;
}

static int GetKeyIDValue(const uchar *pucXmlOneLine, uchar *pucData)
{
    int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "KeyID", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	PubAsc2Bcd(pucBuf, strlen((const char *)pucBuf), pucData);

	return iRet;
}


static int GetHashArithmeticIndexValue(const uchar *pucXmlOneLine, uchar *piData)
{
    int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "HashArithmeticIndex", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	*piData = (uchar)atoi(pucBuf);
	return iRet;
}


static int GetRSAArithmeticIndexValue(const uchar *pucXmlOneLine, uchar *piData)
{
    int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "RSAArithmeticIndex", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	*piData = (uchar)atoi(pucBuf);

	return iRet;
}


static int GetModuleValue(const uchar *pucXmlOneLine, uchar *pucData)
{
    int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "Module", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	PubAsc2Bcd(pucBuf, strlen((const char *)pucBuf), pucData);

	return iRet;
}

static int GetModuleLengthValue(const uchar *pucXmlOneLine, uchar *piData)
{
    int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "ModuleLength", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	*piData = (uchar)atoi(pucBuf);

	return iRet;
}


static int GetExponentValue(const uchar *pucXmlOneLine, uchar *pucData)
{
    int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "Exponent", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	PubAsc2Bcd(pucBuf, strlen((const char *)pucBuf), pucData);

	return iRet;
}

static int GetExponentLengthValue(const uchar *pucXmlOneLine, uchar *piData)
{
    int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "ExponentLength", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	*piData = (uchar)atoi(pucBuf);

	return iRet;
}

static int GetExpireDateValue(const uchar *pucXmlOneLine, uchar *pucData)
{
    int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "ExpireDate", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	PubAsc2Bcd(pucBuf, strlen((const char *)pucBuf), pucData);

	return iRet;
}

static int GetCheckSumValue(const uchar *pucXmlOneLine, uchar *pucData)
{
    int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "CheckSum", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	PubAsc2Bcd(pucBuf, strlen((const char *)pucBuf), pucData);

	return iRet;
}

//static int ParseEmvCapkChildNode(const uchar *pucXmlOneLine, EMV_CAPK *pstCapkNode)
static int ParseEmvCapkChildNode(const uchar *pucXmlOneLine, void *Data)

{
	int iCapkChildNode = 0;
	int iRet = 0;
	int iSize = 0;
	int i = 0;
	EMV_CAPK *stCapkNode = NULL;
	stCapkNode = (EMV_CAPK *)Data;

	if(pucXmlOneLine == NULL)
	{
		return EMV_XML_FILE_OP_ERR_INVALID_PARAM;
	}

	iCapkChildNode = GetCapkChileNode(pucXmlOneLine);

	
	if(iCapkChildNode < 0)
	{
		return EMV_XML_FILE_OP_ERR_NODE_NOT_EXIST;
	}

	switch(iCapkChildNode)
	{
		case RID:
			iRet = GetRIDValue(pucXmlOneLine, stCapkNode->RID);
			break;
		case KEYID:
			iRet = GetKeyIDValue(pucXmlOneLine, &(stCapkNode->KeyID));
			break;
		case HASHARITHMETICINDEX:
			iRet = GetHashArithmeticIndexValue(pucXmlOneLine, &(stCapkNode->HashInd));
			break;
		case RSAARITHMRTICINDEX:
			iRet = GetRSAArithmeticIndexValue(pucXmlOneLine, &(stCapkNode->ArithInd));
			break;
		case MODULELENGTH:
			iRet = GetModuleLengthValue(pucXmlOneLine, &(stCapkNode->ModulLen));
			break;
		case MODULE:
			iRet = GetModuleValue(pucXmlOneLine, stCapkNode->Modul);
			break;
		case EXPONENTLENGTH:
			iRet = GetExponentLengthValue(pucXmlOneLine, &(stCapkNode->ExponentLen));
			break;
		case EXPONENT:
			iRet = GetExponentValue(pucXmlOneLine, stCapkNode->Exponent);
			break;
		case EXPIREDATE:
			iRet = GetExpireDateValue(pucXmlOneLine, stCapkNode->ExpDate);
			break;
		case CHECKSUM:
			iRet = GetCheckSumValue(pucXmlOneLine, stCapkNode->CheckSum);
			break;

		default:
			break;
	}
	
	
#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("ParseEmvCapkChildNode---- iCapkChildNode = %d iSize = %d iRet = %d\n", iCapkChildNode, iSize, iRet);
#endif
	
	return iRet;
}


//begine to parse ics

static int GetIcsChileNode(const uchar *pucXmlOneLine)
{
	if(pucXmlOneLine == NULL)
	{
		return EMV_XML_FILE_OP_ERR_INVALID_PARAM;
	}
	if(strstr(pucXmlOneLine, "<Type") != NULL)
	{
		return TYPE;
	}
	if(strstr(pucXmlOneLine, "<TerminalType") != NULL)
	{
		return TERMINALTYPE;
	}
	if(strstr(pucXmlOneLine, "<CardDataInputCapability") != NULL)
	{
		return CARDDATAINPUTCAPABILITY;
	}
	if(strstr(pucXmlOneLine, "<CVMCapability") != NULL)
	{
		return CVMCAPABILITY;
	}
	if(strstr(pucXmlOneLine, "<SecurityCapability") != NULL)
	{
		return SECURITYCAPABILITY;
	}
	if(strstr(pucXmlOneLine, "<AdditionalTerminalCapabilities") != NULL)
	{
		return ADDITIONALTERMINALCAPABILITIES;
	}
	if(strstr(pucXmlOneLine, "<GetDataForPINTryCounter") != NULL)
	{
		return GETDATAFORPINTRYCOUNTER;
	}
	if(strstr(pucXmlOneLine, "<BypassPINEntry") != NULL)
	{
		return BYPASSPINENTRY;
	}
	if(strstr(pucXmlOneLine, "<SubsequentBypassPINEntry") != NULL)
	{
		return SUBSEQUENBYPASSPINENTRY;
	}
	if(strstr(pucXmlOneLine, "<ExceptionFileSupported") != NULL)
	{
		return EXCEPTIONFILESUPPORTED;
	}
	if(strstr(pucXmlOneLine, "<ForcedOnlineCapability") != NULL)
	{
		return FORCEDONLINECAPABILITY;
	}
	if(strstr(pucXmlOneLine, "<IssuerReferralsSupported") != NULL)
	{
		return ISSUERFEFERRALSSUPPORTED;
	}
	if(strstr(pucXmlOneLine, "<ConfigurationCheckSum") != NULL)
	{
		return CONFIGURATIONCHECKSUM;
	}
	else
	{
		return EMV_XML_FILE_OP_ERR_INVALID_PARAM;
	}

}


static int GetIcsTypeValue(const uchar *pucXmlOneLine, uchar *pucData)
{
    int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "Type", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	//memcpy(pucData, pucBuf, strlen(pucBuf));
	strcpy(pucData, pucBuf);
	return iRet;
}

static int GetIcsTerminalTypeValue(const uchar *pucXmlOneLine, uchar *pucData)
{
    int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "TerminalType", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	PubAsc2Bcd(pucBuf, strlen((const char *)pucBuf), pucData);
	return iRet;
}


static int GetCardDataInputCapabilityValue(const uchar *pucXmlOneLine, uchar *pucData)
{
    int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "CardDataInputCapability", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	PubAsc2Bcd(pucBuf, strlen((const char *)pucBuf), pucData);
	return iRet;
}


static int GetCVMCapabilityValue(const uchar *pucXmlOneLine, uchar *pucData)
{
    int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "CVMCapability", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	PubAsc2Bcd(pucBuf, strlen((const char *)pucBuf), pucData);

	return iRet;
}

static int GetSecurityCapabilityValue(const uchar *pucXmlOneLine, uchar *pucData)
{
    int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "SecurityCapability", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	PubAsc2Bcd(pucBuf, strlen((const char *)pucBuf), pucData);

	return iRet;
}

static int GetAdditionalTerminalCapabilitiesValue(const uchar *pucXmlOneLine, uchar *pucData)
{
    int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "AdditionalTerminalCapabilities", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	PubAsc2Bcd(pucBuf, strlen((const char *)pucBuf), pucData);

	return iRet;
}


static int GetGetDataForPINTryCounterValue(const uchar *pucXmlOneLine, int *piData)
{
	int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "GetDataForPINTryCounter", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	*piData = (uchar)atoi(pucBuf);
	
	return iRet;
}


static int GetBypassPINEntryValue(const uchar *pucXmlOneLine, int *piData)
{
	int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "BypassPINEntry", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	*piData = (uchar)atoi(pucBuf);

	return iRet;
}


static int GetSubsequentBypassPINEntryValue(const uchar *pucXmlOneLine, int *piData)
{
	int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "SubsequentBypassPINEntry", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	*piData = (uchar)atoi(pucBuf);

	return iRet;
}

static int GetExceptionFileSupportedValue(const uchar *pucXmlOneLine, int *piData)
{
	int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "ExceptionFileSupported", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	*piData = (uchar)atoi(pucBuf);

	return iRet;
}

static int GetForcedOnlineCapabilityValue(const uchar *pucXmlOneLine, int *piData)
{
	int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "ForcedOnlineCapability", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	*piData = (uchar)atoi(pucBuf);

	return iRet;
}

static int GetIssuerReferralsSupportedValue(const uchar *pucXmlOneLine, int *piData)
{
	int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "IssuerReferralsSupported", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	*piData = (uchar)atoi(pucBuf);

	return iRet;
}


static int GetConfigurationCheckSumValue(const uchar *pucXmlOneLine, uchar *pucData)
{
    int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "ConfigurationCheckSum", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	PubAsc2Bcd(pucBuf, strlen((const char *)pucBuf), pucData);

	return iRet;
}


static int ParseEmvIcsChildNode(const uchar *pucXmlOneLine, void *Data)
{
	int iIcsChildNode = 0;
	int iRet = 0;
	int iSize = 0;
	int i = 0;
	
	EMV_ICS_NODE_T *stIcsNode = NULL;
	stIcsNode = (EMV_ICS_NODE_T *)Data;

	if(pucXmlOneLine == NULL)
	{
		return EMV_XML_FILE_OP_ERR_INVALID_PARAM;
	}

	iIcsChildNode = GetIcsChileNode(pucXmlOneLine);
	if(iIcsChildNode < 0)
	{
		return EMV_XML_FILE_OP_ERR_NODE_NOT_EXIST;
	}

	switch(iIcsChildNode)
	{
		case TYPE:
			iRet = GetIcsTypeValue(pucXmlOneLine, stIcsNode->Type);
			break;
		case TERMINALTYPE:
			iRet = GetIcsTerminalTypeValue(pucXmlOneLine, &(stIcsNode->TerminalType));
			break;
		case CARDDATAINPUTCAPABILITY:
			iRet = GetCardDataInputCapabilityValue(pucXmlOneLine, &(stIcsNode->CardDataInputCapability));
			break;
		case CVMCAPABILITY:
			iRet = GetCVMCapabilityValue(pucXmlOneLine, &(stIcsNode->CVMCapability));
			break;
		case SECURITYCAPABILITY:
			iRet = GetSecurityCapabilityValue(pucXmlOneLine, &(stIcsNode->SecurityCapability));
			break;
		case ADDITIONALTERMINALCAPABILITIES:
			iRet = GetAdditionalTerminalCapabilitiesValue(pucXmlOneLine, stIcsNode->AdditionalTerminalCapabilities);
			break;
		case GETDATAFORPINTRYCOUNTER:
			iRet = GetGetDataForPINTryCounterValue(pucXmlOneLine, &(stIcsNode->GetDataForPINTryCounter));
			break;
		case BYPASSPINENTRY:
			iRet = GetBypassPINEntryValue(pucXmlOneLine, &(stIcsNode->BypassPINEntry));
			break;
		case SUBSEQUENBYPASSPINENTRY:
			iRet = GetSubsequentBypassPINEntryValue(pucXmlOneLine, &(stIcsNode->SubsequentBypassPINEntry));
			break;
		case EXCEPTIONFILESUPPORTED:
			iRet = GetExceptionFileSupportedValue(pucXmlOneLine, &(stIcsNode->ExceptionFileSupported));
			break;
		case FORCEDONLINECAPABILITY:
			iRet = GetForcedOnlineCapabilityValue(pucXmlOneLine, &(stIcsNode->ForcedOnlineCapability));
			break;
		case ISSUERFEFERRALSSUPPORTED:
			iRet = GetIssuerReferralsSupportedValue(pucXmlOneLine, &(stIcsNode->IssuerReferralsSupported));
			break;
		case CONFIGURATIONCHECKSUM:
			iRet = GetConfigurationCheckSumValue(pucXmlOneLine, stIcsNode->ConfigurationCheckSum);
			
			break;
		default:
			break;
	}

	
#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("ParseEmvIcsChildNode---- GetIcsChileNode = %d iSize = %d iRet = %d\n", iIcsChildNode, iSize, iRet);
#endif
	
	return iRet;
}



//begine to parse REVOCATIONLIST
static int GetRevoketionChileNode(const uchar *pucXmlOneLine)
{
	if(pucXmlOneLine == NULL)
	{
		return EMV_XML_FILE_OP_ERR_INVALID_PARAM;
	}
	if(strstr(pucXmlOneLine, "<RID") != NULL)
	{
		return REVOKERID;
	}
	if(strstr(pucXmlOneLine, "<KeyID") != NULL)
	{
		return REVOKEKEYID;
	}
	if(strstr(pucXmlOneLine, "<CertificateSN") != NULL)
	{
		return CERTIFICATESN;
	}
	else
	{
		return EMV_XML_FILE_OP_ERR_INVALID_PARAM;
	}

}

static int GetRevokeCertificateRIDValue(const uchar *pucXmlOneLine, uchar *pucData)
{
    int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "RID", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	PubAsc2Bcd(pucBuf, strlen((const char *)pucBuf), pucData);

	return iRet;
}

static int GetRevokeCertificateKeyIDValue(const uchar *pucXmlOneLine, uchar *pucData)
{
   	int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "KeyID", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	PubAsc2Bcd(pucBuf, strlen((const char *)pucBuf), pucData);
	return iRet;
}

static int GetRevokeCertificateSNValue(const uchar *pucXmlOneLine, uchar *pucData)
{
    int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "CertificateSN", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	PubAsc2Bcd(pucBuf, strlen((const char *)pucBuf), pucData);

	return iRet;
}

static int ParseEmvRevokeCertificateChildNode(const uchar *pucXmlOneLine, void *Data)
{
	int iRevokeChildNode = 0;
	int iRet = 0;
	int iSize = 0;
	int i = 0;

	EMV_REVOCLIST *stRevokeNode = NULL;
	stRevokeNode = (EMV_REVOCLIST *)Data;

	if(pucXmlOneLine == NULL)
	{
		return EMV_XML_FILE_OP_ERR_INVALID_PARAM;
	}

	iRevokeChildNode = GetRevoketionChileNode(pucXmlOneLine);

	
	if(iRevokeChildNode < 0)
	{
		return EMV_XML_FILE_OP_ERR_NODE_NOT_EXIST;
	}

	switch(iRevokeChildNode)   	
	{
		case REVOKERID:
			iRet = GetRevokeCertificateRIDValue(pucXmlOneLine, stRevokeNode->ucRid);
			break;
		case REVOKEKEYID:
			iRet = GetRevokeCertificateKeyIDValue(pucXmlOneLine, &(stRevokeNode->ucIndex));
			break;
		case CERTIFICATESN:
			iRet = GetRevokeCertificateSNValue(pucXmlOneLine, stRevokeNode->ucCertSn);
			break;

		default:
			break;
	}
	
#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("ParseEmvRevokeCertificateChildNode---- GetRevoketionChileNode = %d iSize = %d iRet = %d\n", iRevokeChildNode, iSize, iRet);
#endif
	
	return iRet;
}


//begine to parse terminal info
static int GetTerminalInfoChileNode(const uchar *pucXmlOneLine)
{
	if(pucXmlOneLine == NULL)
	{
		return EMV_XML_FILE_OP_ERR_INVALID_PARAM;
	}
	if(strstr(pucXmlOneLine, "MerchantID") != NULL)
	{
		return MERCHANTID;
	}
	if(strstr(pucXmlOneLine, "TerminalID") != NULL)
	{
		return TERMINALID;
	}
	if(strstr(pucXmlOneLine, "TerminalCountryCode") != NULL)
	{
		return TERMINALCOUNTRYCODE;
	}
	if(strstr(pucXmlOneLine, "TerminalCurrencyCode") != NULL)
	{
		return TERMINALCURRENCYCODE;
	}
	if(strstr(pucXmlOneLine, "TerminalCurrencyExponent") != NULL)
	{
		return TERMINALCURRENTCYEXPONENT;
	}
	if(strstr(pucXmlOneLine, "ReferenceCurrencyCode") != NULL)
	{
		return REFERENCECURRENCYCODE;
	}
	if(strstr(pucXmlOneLine, "ReferenceCurrencyExponent") != NULL)
	{
		return REFERENCECURRENTEXPONENT;
	}
	if(strstr(pucXmlOneLine, "ConversionRatio") != NULL)
	{
		return CONVERSIONRATIO;
	}
	if(strstr(pucXmlOneLine, "MerchantName") != NULL)
	{
		return MECHANTNAME;
	}
	if(strstr(pucXmlOneLine, "MerchantLocation") != NULL)
	{
		return MERCHANTLOCATION;
	}
	if(strstr(pucXmlOneLine, "MerchantCategoryCode") != NULL)
	{
		return MERCHANTCATEGORYCODE;
	}
	else
	{
		return EMV_XML_FILE_OP_ERR_INVALID_PARAM;
	}

}

static int GetMerchantIDValue(const uchar *pucXmlOneLine, uchar *pucData)
{
    int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "MerchantID", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	//memcpy(pucData, pucBuf, sizeof(pucData));
	strcpy(pucData, pucBuf);
	return iRet;
}

static int GetTerminalIDValue(const uchar *pucXmlOneLine, uchar *pucData)
{
    int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "TerminalID", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	//memcpy(pucData, pucBuf, sizeof(pucData));
	strcpy(pucData, pucBuf);
	return iRet;
}

static int GetTerminalCountryCodeValue(const uchar *pucXmlOneLine, uchar *pucData)
{
    int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "TerminalCountryCode", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	PubAsc2Bcd(pucBuf, strlen((const char *)pucBuf), pucData);

	return iRet;
}

static int GetTerminalCurrencyCodeValue(const uchar *pucXmlOneLine, uchar *pucData)
{
    int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "TerminalCountryCode", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	PubAsc2Bcd(pucBuf, strlen((const char *)pucBuf), pucData);

	return iRet;
}

static int GetTerminalCurrencyExponentValue(const uchar *pucXmlOneLine, uchar *piData)
{
	int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "ForcedOnlineCapability", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	*piData = (uchar)atoi(pucBuf);
	return iRet;
}

static int GetReferenceCurrencyCodeValue(const uchar *pucXmlOneLine, uchar *pucData)
{
    int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "ReferenceCurrencyCode", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	PubAsc2Bcd(pucBuf, strlen((const char *)pucBuf), pucData);

	return iRet;
}

static int GetReferenceCurrencyExponentValue(const uchar *pucXmlOneLine, uchar *piData)
{
	int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "ReferenceCurrencyExponent", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	*piData = (uchar)atoi(pucBuf);
	return iRet;
}

static int GetMerchantCategoryCodeValue(const uchar *pucXmlOneLine, uchar *pucData)
{
    int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "MerchantCategoryCode", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	PubAsc2Bcd(pucBuf, strlen((const char *)pucBuf), pucData);

	return iRet;
}

static int GetConversionRatiotValue(const uchar *pucXmlOneLine, uchar *piData)
{
	int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "ConversionRatio", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	*piData = (uchar)atoi(pucBuf);
	return iRet;
}


static int GetMerchantNameValue(const uchar *pucXmlOneLine, uchar *pucData)
{
    int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "MerchantName", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	//memcpy(pucData, pucBuf, sizeof(pucData));
	strcpy(pucData, pucBuf);
	return iRet;
}


static int GetMerchantLocationValue(const uchar *pucXmlOneLine, uchar *pucData)
{
    int iRet = 0;
	uchar pucBuf[EMV_BUF_NODE_VALUE_LEN] = {0};

	memset(pucBuf, 0, sizeof(pucBuf));
	iRet = XmlParseGetNodeValue(pucXmlOneLine, "MerchantLocation", pucBuf);
	if(iRet < 0)
	{
		return iRet;
	}
	//memcpy(pucData, pucBuf, sizeof(pucData));
	strcpy(pucData, pucBuf);
	return iRet;
}

static int ParseEmvTerminalInfoChildNode(const uchar *pucXmlOneLine, void *Data)
{
	int iTermInfoChildNode = 0;
	int iRet = 0;
	int iSize = 0;
	int i = 0;

	EMV_TERMINALINFO_NODE_T *stTermInfoNode = NULL;
	stTermInfoNode = (EMV_TERMINALINFO_NODE_T *)Data;

	if(pucXmlOneLine == NULL)
	{
		return EMV_XML_FILE_OP_ERR_INVALID_PARAM;
	}

	iTermInfoChildNode = GetTerminalInfoChileNode(pucXmlOneLine);

	if(iTermInfoChildNode < 0)
	{
		return EMV_XML_FILE_OP_ERR_NODE_NOT_EXIST;
	}

	switch(iTermInfoChildNode)
	{
		case MERCHANTID:
			iRet = GetMerchantIDValue(pucXmlOneLine, stTermInfoNode->aucMerchId);
			break;
		case TERMINALID:
			iRet = GetTerminalIDValue(pucXmlOneLine, stTermInfoNode->aucTermId);
			break;
		case TERMINALCOUNTRYCODE:
			iRet = GetTerminalCountryCodeValue(pucXmlOneLine, stTermInfoNode->aucCountryCode);
			break;
		case TERMINALCURRENCYCODE:
			iRet = GetTerminalCurrencyCodeValue(pucXmlOneLine, stTermInfoNode->aucTransCurrCode);
			break;
		case TERMINALCURRENTCYEXPONENT:
			iRet = GetTerminalCurrencyExponentValue(pucXmlOneLine, &(stTermInfoNode->ucTerminalCurrencyExponent));
			break;
		case REFERENCECURRENCYCODE:
			iRet = GetReferenceCurrencyCodeValue(pucXmlOneLine, stTermInfoNode->aucReferCurrCode);
			break;
		case REFERENCECURRENTEXPONENT:
			iRet = GetReferenceCurrencyExponentValue(pucXmlOneLine, &(stTermInfoNode->ucReferenceCurrencyExponent));
			break;
		case CONVERSIONRATIO:
			iRet = GetConversionRatiotValue(pucXmlOneLine, &(stTermInfoNode->ucConversionRatio));
			break;
		case MECHANTNAME:
			iRet = GetMerchantNameValue(pucXmlOneLine, stTermInfoNode->aucMerchName);
			break;
		case MERCHANTLOCATION:
			iRet = GetMerchantLocationValue(pucXmlOneLine, stTermInfoNode->aucMerchantLocation);
			break;
		case MERCHANTCATEGORYCODE:
			iRet = GetMerchantCategoryCodeValue(pucXmlOneLine, stTermInfoNode->aucMerchCateCode);
			break;

		default:
			break;
	}
	
	
#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("ParseEmvTerminalInfoChildNode---- GetTerminalInfoChileNode = %d iSize = %d iRet = %d\n", iTermInfoChildNode, iSize, iRet);
#endif
	
	return iRet;
}


//static int FindFunctionIndex(const uchar *pucXmlOneLine, const uchar *pucNodeName)
static int FindFunctionIndex(const uchar *pucNodeName, NODE_FUNC_TAB_T *vParseListFuncTab, int iSize)
{
	int i = 0;
	//ComDebugTx("FindFunctionIndex iSize = %d\n", iSize);

	for(i = 0; i < iSize; i++)
	{
		if(strcmp(pucNodeName, vParseListFuncTab[i].ucNodeName) == 0)
		{
			//ComDebugTx("FindFunctionIndex i = %d\n", i);
			//ComDebugTx("FindFunctionIndex vParseNodeFuncTab[i].iLen = %d\n", vParseListFuncTab[i].iLen);
			//memset(vParseListFuncTab[i].pOutData, 0, vParseListFuncTab[i].iLen);
			//return vParseListFuncTab[i].vFunc(pucXmlOneLine, vParseListFuncTab[i].pOutData);
			return i;
		}
	}
	return EMV_XML_FILE_OP_ERR_FUNCTIONE_NOT_FOUNTD;
}

static int FindNodePositonInFile(const uchar *pucFileName, const uchar *pucNodeName, int iPos)
{
	int iFd = 0;
	int iFileSize = 0;
	int iSearchLen = 0;
	uchar ucReadBuf[EMV_FILE_READ_BUF_LEN + 1] = {0};
	uchar ucTempBuf[EMV_TEMP_BUF_LEN + 1] = {0};
	uchar ucParseBuf[EMV_FILE_READ_BUF_LEN + 1] = {0};
	uchar *pucStart  = NULL;
	uchar *pucLastEnterPos = NULL;
	int iRet = 0;
	int iOffset = 0;
	ulong uiPosition = 0;
	int iLseek = 0;

	iFd = PdkFile_Open(pucFileName);
	//ComDebugTx("FindNodePositonInFile PdkFile_Open iFd = %d\n", iFd);
	if(iFd < 0)
	{
		return iFd;
	}

	iFileSize = PdkFile_GetSize(pucFileName);
	//ComDebugTx("FindNodePositonInFile PdkFile_GetSize iFileSize = %d\n", iFileSize);
	if(iFileSize < 0)
	{
		PdkFile_Close(iFd);
		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("FindNodePositonInFile PdkFile_GetSize iFileSize = %d\n", iFileSize);
		#endif
		return iFileSize;
	}

	iLseek = PdkFile_Seek (iFd, iPos, SEEK_CUR);
	//ComDebugTx("FindNodePositonInFile PdkFile_Seek iPos PdkFile_Seek = %d\n", iLseek);
	if(iLseek < 0)
	{
		PdkFile_Close(iFd);
		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("FindNodePositonInFile PdkFile_Seek PdkFile_Seek = %d\n", iLseek);
		#endif
		return iLseek;
	}

	while(iSearchLen < iFileSize)
	{
		memset(ucReadBuf, 0, sizeof(ucReadBuf));
		iRet = PdkFile_Read(iFd, ucReadBuf, 1024);
		//ComDebugTx("FindNodePositonInFile PdkFile_Read ucReadBuf = %s\n", ucReadBuf);
		//ComDebugTx("FindNodePositonInFile PdkFile_Read iRet = %d\n", iRet);
		if(iRet < 0)
		{
			PdkFile_Close(iFd);
			#ifdef EMV_XML_FILE_OP_DEBUG
			ComDebugTx("FindNodePositonInFile PdkFile_Read iRet = %d\n", iRet);
			#endif
			return iRet;
		}

		//every time ,we should confirm the last line is whole line
		pucLastEnterPos = strrchr(ucReadBuf,'\x0a');
		if(pucLastEnterPos == NULL)
		{
			PdkFile_Close(iFd);
			return EMV_XML_FILE_OP_ERR_ONELINE_OVER_1024;
		}
		
		memcpy(ucParseBuf, ucReadBuf, pucLastEnterPos - ucReadBuf);
		//ComDebugTx("FindNodePositonInFile memcpy ucParseBuf = %s\n", ucParseBuf);
		//ComDebugTx("FindNodePositonInFile memcpy pucNodeName = %s\n", pucNodeName);
		pucStart = strstr(ucParseBuf, pucNodeName);
		if(pucStart == NULL)
		{
		    //the len have search
			iOffset = 1024 - (pucLastEnterPos - ucReadBuf);
			//ComDebugTx("FindNodePositonInFile 1024 - (pucLastEnterPos - ucReadBuf) = %d\n", iOffset);
			iSearchLen = iSearchLen + (pucLastEnterPos - ucReadBuf);
			//ComDebugTx("FindNodePositonInFile pucstart = NULL iSearchLen = %d\n", iSearchLen);
			iLseek = PdkFile_Seek(iFd, -iOffset, SEEK_CUR);
			if(iLseek < 0)
			{
				PdkFile_Close(iFd);
				#ifdef EMV_XML_FILE_OP_DEBUG
				ComDebugTx("FindNodePositonInFile PdkFile_Seek -iOffsetPdkFile_Seek = %d\n", iLseek);
				#endif
				return iLseek;
			}
			continue;
		}
		else
		{
			//ComDebugTx("FindNodePositonInFile pucstart !=NULl iSearchLen = %d\n", iSearchLen);
			//ComDebugTx("FindNodePositonInFile pucstart !=NULl (pucStart - ucParseBuf) = %d\n", (pucStart - ucParseBuf));
			uiPosition = iSearchLen + (pucStart - ucParseBuf);
			//ComDebugTx("FindNodePositonInFile pucstart !=NULl uiPosition = %d\n", uiPosition);
			PdkFile_Close(iFd);
			return uiPosition;
		}
	}
	PdkFile_Close(iFd);
	return EMV_XML_FILE_OP_ERR_NODE_NOT_EXIST;
}


//static int ParseList(const uchar *pucFileName, void *OutData, const uchar *pucListStart, const uchar *pucListEnd,  const uchar *pucNodeStart, const uchar *pucNodeEnd, int *iFlag)
static int ParseList(const uchar *pucFileName, const uchar *pucListStart, const uchar *pucListEnd,  const uchar *pucNodeStart, const uchar *pucNodeEnd)
{
	int iRet = 0;
	int iListPos = 0;
	uchar *pucNodeEndTag = NULL;
	uchar *pucListEndTag = NULL;
	int iFd = 0;
	int iFileSize = 0;
	int iLseek = 0;
	uchar ucReadBuf[EMV_FILE_READ_BUF_LEN + 1] = {0};
	uchar ucParseBuf[EMV_FILE_READ_BUF_LEN + 1] = {0};
	uchar ucXmlLineBuf[EMV_FILE_ONELINE_BUF_LEN] = {0};
	uchar *pucStart = NULL;
	uchar *pucLastEnterPos = NULL;
	int iSearchLen = 0;
	int iLen = 0;
	int iHaveGetLen = 0;
	int iOffset = 0;
	int iIndex = 0;
	int iReadLen = 0;

	EMV_AID_NODE_T stAidNode = {0};
	EMV_CAPK stCapkNode = {0};
	EMV_ICS_NODE_T stIcsNode = {0};
	EMV_REVOCLIST stRevokeNode = {0};
	EMV_TERMINALINFO_NODE_T stTermInfoNode = {0};

	NODE_FUNC_TAB_T vParseListFuncTab[] =
	{
		{"<AID>", ParseEmvAidChildNode, &stAidNode, sizeof(stAidNode)},
		{"<CAPK>", ParseEmvCapkChildNode, &stCapkNode, sizeof(stCapkNode)},
		{"<ICS>", ParseEmvIcsChildNode, &stIcsNode, sizeof(stIcsNode)},
		{"<REVOKEDCERTIFICATE>", ParseEmvRevokeCertificateChildNode, &stRevokeNode, sizeof(stRevokeNode)},
		{"<TERMINALCONFIGURATION>", ParseEmvTerminalInfoChildNode, &stTermInfoNode, sizeof(stTermInfoNode)},
	};

	if(pucNodeStart == NULL || pucNodeEnd == NULL)
	{
		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("ParseList EMV_XML_FILE_OP_ERR_INVALID_PARAM NULL\n");
		#endif
		return EMV_XML_FILE_OP_ERR_INVALID_PARAM;
	}

	if(pucListStart != NULL)
	{
		iListPos = FindNodePositonInFile(pucFileName, pucListStart, 0);
		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("ParseList FindNodePositonInFile != NULL iListPos = %d\n", iListPos);
		#endif
	}
	else
	{
		iListPos = FindNodePositonInFile(pucFileName, pucNodeStart, 0);
		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("ParseList FindNodePositonInFile == NULL iListPos = %d\n", iListPos);
		#endif
	}
	
	iFd = PdkFile_Open(pucFileName);
	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("ParseList PdkFile_Open iFd = %d\n", iFd);
	#endif
	if(iFd < 0)
	{
		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("ParseList PdkFile_Open iFd = %d\n", iFd);
		#endif
		return iFd;
	}

	iFileSize = PdkFile_GetSize(pucFileName);
	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("ParseList PdkFile_GetSize iFileSize = %d\n", iFileSize);
	#endif
	if(iFileSize < 0)
	{
		PdkFile_Close(iFd);
		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("ParseList PdkFile_GetSize iFileSize = %d\n", iFileSize);
		#endif
		return iFileSize;
	}

	iLseek = PdkFile_Seek (iFd, iListPos, SEEK_CUR);
	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("ParseList PdkFile_Seek PdkFile_Seek = %d\n", iLseek);
	#endif
	if(iLseek < 0)
	{
		PdkFile_Close(iFd);
		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("ParseList PdkFile_Seek PdkFile_Seek = %d\n", iLseek);
		#endif
		return iFileSize;
	}

	while((iReadLen + iListPos) < iFileSize)
	{
		memset(ucReadBuf, 0, sizeof(ucReadBuf));
		iRet = PdkFile_Read(iFd, ucReadBuf, 1024);
		if(iRet < 0)
		{
			PdkFile_Close(iFd);
			#ifdef EMV_XML_FILE_OP_DEBUG
			ComDebugTx("ParseList PdkFile_Read iRet = %d\n", iRet);
			#endif
			return iRet;
		}
		iReadLen +=  iRet;
		#if 0
		ComDebugTx("ParseList PdkFile_Read iReadLen = %d\n", iReadLen);
		ComDebugTx("ParseList PdkFile_Read ucReadBuf = %s\n", ucReadBuf);
		#endif

		//every time ,we should confirm the last line is whole line
		pucLastEnterPos = strrchr(ucReadBuf,'\x0a');
		if(pucLastEnterPos == NULL)
		{
			PdkFile_Close(iFd);
			#ifdef EMV_XML_FILE_OP_DEBUG
			ComDebugTx("ParseList pucLastEnterPos == NULL\n");
			#endif
			return EMV_XML_FILE_OP_ERR_ONELINE_OVER_1024;
		}
		//ComDebugTx("ParseList pucLastEnterPos != NULL\n");
		memset(ucParseBuf, 0, sizeof(ucParseBuf));
		memcpy(ucParseBuf, ucReadBuf, pucLastEnterPos - ucReadBuf + 1);
		//ComDebugTx("ParseList  ucParseBuf = %s\n", ucParseBuf);
		//ComDebugTx("ParseList  pucNodeStart = %s\n", pucNodeStart);
			
		while((iHaveGetLen) < (pucLastEnterPos - ucReadBuf + 1))
		{
			memset(ucXmlLineBuf, 0, sizeof(ucXmlLineBuf));
			//offset mean hava get len,the parsebuf's data every line is whole line   include \r\n	
			//ComDebugTx("ParseList  XmlGetOneLineData iHaveGetLen = %d\n", iHaveGetLen);
			//iRet = XmlGetOneLineData(ucParseBuf + iHaveGetLen, &iLen, ucXmlLineBuf);
			iRet = XmlGetOneLineData(ucParseBuf + iHaveGetLen, &iLen, ucXmlLineBuf);
			//ComDebugTx("ParseList  XmlGetOneLineData ucXmlLineBuf = %s\n", ucXmlLineBuf);
			//ComDebugTx("ParseList  XmlGetOneLineData iLen = %d\n", iLen);

			if(iRet < 0)
			{
				#ifdef EMV_XML_FILE_OP_DEBUG
				ComDebugTx("ParseList XmlGetOneLineData iRet = %d\n", iRet);
				#endif
				PdkFile_Close (iFd);
				return iRet;
			}
			iHaveGetLen += iLen;
			//ComDebugTx("ParseList iHaveGetLen iHaveGetLen = %d\n", iHaveGetLen);
			//ComDebugTx("ParseList iHaveGetLen (pucLastEnterPos - ucReadBuf) = %d\n", (pucLastEnterPos - ucReadBuf + 1));

			//init the buf that use to save data
			if(strstr(ucXmlLineBuf, pucNodeStart) != NULL)
			{
				//ComDebugTx("ParseList init buf \n");
				iIndex = FindFunctionIndex(pucNodeStart, vParseListFuncTab, sizeof(vParseListFuncTab)/sizeof(vParseListFuncTab[0]));
				//ComDebugTx("ParseList  FindFunctionIndex 11111 iIndex = %d\n", iIndex);
				if(iIndex == EMV_XML_FILE_OP_ERR_FUNCTIONE_NOT_FOUNTD)
				{
					PdkFile_Close(iFd);
					return EMV_XML_FILE_OP_ERR_FUNCTIONE_NOT_FOUNTD;
				}
				memset(vParseListFuncTab[iIndex].pOutData ,0,vParseListFuncTab[iIndex].iLen);
				//continue;
			}

			//for list
			if((pucListEnd != NULL) && (pucListStart != NULL))
			{
				//ComDebugTx("ParseList  pucListEnd pucListEnd = %s\n", pucListEnd);
				pucListEndTag = strstr(ucXmlLineBuf, pucListEnd);
				if(pucListEndTag != NULL)
				{
					PdkFile_Close(iFd);
					#ifdef EMV_XML_FILE_OP_DEBUG
					ComDebugTx("ParseList  pucListEndTag pucListEndTag = NULL\n");
					#endif
					return EMV_XML_FILE_LIST_END;
				}

				//ComDebugTx("ParseList  pucNodeEnd pucNodeEnd = %s\n", pucNodeEnd);
				pucNodeEndTag = strstr(ucXmlLineBuf, pucNodeEnd);
				if(pucNodeEndTag != NULL)
				{
					//ComDebugTx("ParseList  pucNodeEndTag pucNodeEndTag != NULL return XML_PARSE_OK\n");
					 PrintNodeStruct(pucNodeStart, vParseListFuncTab[iIndex].pOutData, vParseListFuncTab[iIndex].iLen);		
					//continue;
				}
				else
				{
					//ComDebugTx("vFunParseNodeCb begin\n");
					iIndex = FindFunctionIndex(pucNodeStart, vParseListFuncTab, sizeof(vParseListFuncTab)/sizeof(vParseListFuncTab[0]));
					//ComDebugTx("ParseList  FindFunctionIndex iIndex = %d\n", iIndex);
					if(iIndex == EMV_XML_FILE_OP_ERR_FUNCTIONE_NOT_FOUNTD)
					{
						PdkFile_Close(iFd);
						return EMV_XML_FILE_OP_ERR_FUNCTIONE_NOT_FOUNTD;
					}
					if((strstr(ucXmlLineBuf, pucNodeStart) == NULL) && (strstr(ucXmlLineBuf, pucListStart) == NULL))
				    {
						iRet = vParseListFuncTab[iIndex].vFunc(ucXmlLineBuf, vParseListFuncTab[iIndex].pOutData);
						//ComDebugTx("ParseList  vParseNodeFuncTab for list iRet = %d\n", iRet);
				    }
					
				}
			}
			else//for node
			{
				pucNodeEndTag = strstr(ucXmlLineBuf, pucNodeEnd);
				if(pucNodeEndTag != NULL)
				{
					//ComDebugTx("ParseList  pucNodeEndTag pucNodeEndTag != NULL return XML_PARSE_OK\n");
					 PrintNodeStruct(pucNodeStart, vParseListFuncTab[iIndex].pOutData, vParseListFuncTab[iIndex].iLen);
					PdkFile_Close(iFd);
					return EMV_XML_FILE_NODE_END;
					//continue;
				}
				else
				{
					//ComDebugTx("else vFunParseNodeCb begin\n");
					iIndex = FindFunctionIndex(pucNodeStart, vParseListFuncTab, sizeof(vParseListFuncTab)/sizeof(vParseListFuncTab[0]));
					//ComDebugTx("ParseList  FindFunctionIndex iIndex = %d\n", iIndex);
					if(iIndex == EMV_XML_FILE_OP_ERR_FUNCTIONE_NOT_FOUNTD)
					{
						PdkFile_Close(iFd);
						return EMV_XML_FILE_OP_ERR_FUNCTIONE_NOT_FOUNTD;
					}
					if(strstr(ucXmlLineBuf, pucNodeStart) == NULL)
					{
						iRet = vParseListFuncTab[iIndex].vFunc(ucXmlLineBuf, vParseListFuncTab[iIndex].pOutData);
						//ComDebugTx("ParseList  vParseNodeFuncTab for node iRet = %d\n", iRet);
					}
				}
			}

			//have finish one parsebuf, reset data  //dui de wei zhi
			if(iHaveGetLen == (pucLastEnterPos - ucReadBuf + 1))
			{
				iRet = PdkFile_Seek (iFd, iHaveGetLen - 1024, SEEK_CUR);
				//ComDebugTx("ParseList PdkFile_Seek iHaveGetLen - 1024, SEEK_CUR = %d\n", iRet);
				iHaveGetLen = 0;
				break;
			}
		}
		//parse one aid
	}
	PdkFile_Close(iFd);
	return iRet;
}
	
static int ParseAidList(const uchar *pucFileName)
{
	int iRet = 0;
	int iAidIndex = 0;
	//NODE_RECORD_T stNoeRecord = {0};
	int iNodeEnd = -1;
	int iIndex = 0;
	
	iRet = ParseList(pucFileName, "<AIDLIST>", "</AIDLIST>", "<AID>", "</AID>");
	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("ParseAidList----ParseList iRet  = %d \n", iRet );
	#endif

	iIndex = GetRecordIndex("AID", sizeof(stNoeRecord)/sizeof(stNoeRecord[0]));
	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("ParseAidList----GetRecordIndex iIndex  = %d \n", iIndex );
	#endif
	if(iIndex < 0)
	{
		return iIndex;
	}
	stNoeRecord[iIndex].count = giAidIndex;
	
	//strcpy(stNoeRecord.ucListNodeName,"AID");
	//stNoeRecord.count = giAidIndex;
	iRet = SaveParsedDataToFile(EMV_XML_FILE_HAVE_PARSED, (uchar*)&stNoeRecord, sizeof(stNoeRecord), 0);
	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("ParseAidList---- SaveParsedDataToFile iRet  = %d \n", iRet );
	#endif
	return iRet;
}

static int ParseCapkList(const uchar *pucFileName)
{
	int iRet = 0;
	int iIndex = 0;
	//NODE_RECORD_T stNoeRecord = {0};
	
	iRet = ParseList(pucFileName, "<CAPKLIST>", "</CAPKLIST>", "<CAPK>", "</CAPK>");
	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("ParseCapkList---- iRet = %d \n", iRet);
	#endif

	iIndex = GetRecordIndex("CAPK", sizeof(stNoeRecord)/sizeof(stNoeRecord[0]));
	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("ParseCapkList----GetRecordIndex iIndex  = %d \n", iIndex);
	#endif
	if(iIndex < 0)
	{
		return iIndex;
	}
	stNoeRecord[iIndex].count = giCapkIndex;
	
	//strcpy(stNoeRecord.ucListNodeName,"CAPK");
	//stNoeRecord.count = giCapkIndex;
	iRet = SaveParsedDataToFile(EMV_XML_FILE_HAVE_PARSED, (uchar*)&stNoeRecord, sizeof(stNoeRecord), 0);
	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("ParseCapkList---- SaveParsedDataToFile iRet  = %d \n", iRet );
	#endif
	return iRet;
}

static int ParseIcsList(const uchar *pucFileName)
{
	int iRet = 0;
	int iIndex = 0;
	//NODE_RECORD_T stNoeRecord = {0};
	
	iRet = ParseList(pucFileName, "<ICSCONFIGURATION>", "</ICSCONFIGURATION>", "<ICS>", "</ICS>");
	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("ParseIcsList---- iRet = %d \n", iRet);
	#endif

	iIndex = GetRecordIndex("ICS", sizeof(stNoeRecord)/sizeof(stNoeRecord[0]));
	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("ParseIcsList----GetRecordIndex iRet  = %d \n", iIndex );
	#endif
	if(iIndex < 0)
	{
		return iIndex;
	}
	stNoeRecord[iIndex].count = giIcsIndex;

	//strcpy(stNoeRecord.ucListNodeName,"ICS");
	//stNoeRecord.count = giIcsIndex;
	iRet = SaveParsedDataToFile(EMV_XML_FILE_HAVE_PARSED, (uchar*)&stNoeRecord, sizeof(stNoeRecord), 0);
	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("ParseIcsList---- SaveParsedDataToFile iRet  = %d \n", iRet );
	#endif
	return iRet;
}

static int ParseRevokeCertificateList(const uchar *pucFileName)
{
	int iRet = 0;
	int iIndex = 0;
	//NODE_RECORD_T stNoeRecord = {0};
	
	iRet = ParseList(pucFileName, "<REVOCATIONLIST>", "</REVOCATIONLIST>", "<REVOKEDCERTIFICATE>", "</REVOKEDCERTIFICATE>");
	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("ParseRevokeCertificateList---- iRet = %d \n", iRet);
	#endif

	iIndex = GetRecordIndex("REVOKEDCERTIFICATE", sizeof(stNoeRecord)/sizeof(stNoeRecord[0]));
	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("ParseRevokeCertificateList----GetRecordIndex iIndex  = %d \n", iIndex );
	#endif
	if(iIndex < 0)
	{
		return iIndex;
	}
	stNoeRecord[iIndex].count = giRevokeIndex;
		
	//strcpy(stNoeRecord.ucListNodeName,"REVOKEDCERTIFICATE");
	//stNoeRecord.count = giRevokeIndex;
	iRet = SaveParsedDataToFile(EMV_XML_FILE_HAVE_PARSED, (uchar*)&stNoeRecord, sizeof(stNoeRecord), 0);
	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("ParseRevokeCertificateList---- SaveParsedDataToFile iRet  = %d \n", iRet );
	#endif
	return iRet;
}

static int ParseTerminalInfoList(const uchar *pucFileName)
{
	int iRet = 0;
	int iIndex = 0;
	//NODE_RECORD_T stNoeRecord = {0};
	
	iRet = ParseList(pucFileName, NULL, NULL, "<TERMINALCONFIGURATION>", "</TERMINALCONFIGURATION>");
	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("ParseTerminalInfoList---- iRet = %d \n", iRet);
	#endif

	iIndex = GetRecordIndex("TERMINALCONFIGURATION", sizeof(stNoeRecord)/sizeof(stNoeRecord[0]));
	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("ParseTerminalInfoList----GetRecordIndex iIndex  = %d \n", iIndex );
	#endif
	if(iIndex < 0)
	{
		return iIndex;
	}
	stNoeRecord[iIndex].count = giTermInfoIndex;
		
	//strcpy(stNoeRecord.ucListNodeName,"TERMINALCONFIGURATION");
	//stNoeRecord.count = giTermInfoIndex;
	iRet = SaveParsedDataToFile(EMV_XML_FILE_HAVE_PARSED, (uchar*)&stNoeRecord, sizeof(stNoeRecord), 0);
	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("ParseRevokeCertificateList---- SaveParsedDataToFile iRet  = %d \n", iRet );
	#endif
	return iRet;
}

static void InitGloableVar(void)
{
	giAidIndex = 0;
    giCapkIndex = 0;
    giIcsIndex = 0;
    giRevokeIndex = 0;
    giTermInfoIndex = 0;
	giCurrentOffset = sizeof(stNoeRecord);
}

//init the file whic used to stored the have parsed data,save the node info in the start position of file
static int InitEmvParsedFile(const uchar *pucFileName)
{
	int iFd = 0;
	NODE_RECORD_T stRecord[EMV_PRASED_NODE_CNT] = {0};
	int iRet = 0;

	iFd = PdkFile_Open(pucFileName);
	if(iFd < 0)
	{
		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("InitEmvParsedFile PdkFile_Open iFd = %d\n", iFd);
		#endif
		return iFd;
	}
	#ifdef EMV_XML_FILE_OP_DEBUG
	ComDebugTx("InitEmvParsedFile sizeof(stRecord) = %d\n", sizeof(stRecord));
	#endif
	iRet = PdkFile_Write (iFd, (uchar*)&stRecord, sizeof(stRecord));
	if(iRet < 0)
	{
		#ifdef EMV_XML_FILE_OP_DEBUG
		ComDebugTx("InitEmvParsedFile sizeof(stRecord) = %d\n", sizeof(stRecord));
		#endif
		PdkFile_Close(iFd);
		return iRet;
	}
	PdkFile_Close(iFd);
	return iRet;
}

int ParseEmvFile(const uchar *pucFileName)
{
	int iRet = 0;

	int iFlag = 1;

    while(iFlag)
    {
        InitGloableVar();
	    InitEmvParsedFile(EMV_XML_FILE_HAVE_PARSED);
		ParseAidList(pucFileName);
		ParseCapkList(pucFileName);
		ParseIcsList(pucFileName);
		ParseRevokeCertificateList(pucFileName);
		ParseTerminalInfoList(pucFileName);
		//GetAidData();
		//GetCapkData();
	    //GetIcsData();
		//GetRevokeData();
		//GetTermInfoData();

		iFlag = 0;

//		if(getkey()== KEYENTER)
//		{
//			iFlag = 1;
//		}
    }
	return iRet;
}


