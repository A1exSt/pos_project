/*------------------------------------------------------------
* FileName: clssproc.c
* Author: liukai
* Date: 2016-07-28
------------------------------------------------------------*/
#include "..\inc\global.h"

static Clss_TransParam sg_tClssTransParam;
static unsigned char sg_aucOutcomeParamSet[8]={0};
static unsigned char sg_aucUserInterReqData[22]={0};
static unsigned char sg_aucErrIndication[6]={0};
static CLSS_DISC_DATA_MC sg_tDiscretionayData;
static uchar sg_ucAppType = KERNTYPE_DEF;
static int sg_iAppTornLogNum=0;//number of Tornlog
static CLSS_TORN_LOG_RECORD sg_tAppTornTransLog[5];//Torn Transaction Log
static unsigned char sg_aucFinalAID[17]={0};
static unsigned char sg_ucFinalAIDLen=0;
static unsigned char sg_ucDRLSupportFlg=1;
static unsigned char sg_aucProID[17]={0};
static int sg_iProIDLen=0;
static Clss_ProgramID sg_tProgInfo;
static unsigned char sg_ucTransPath=0;
static unsigned char sg_ucACType=0;
static CLSS_OUTCOME_DATA  sg_tOutComeData;
static Clss_PreProcInfo sg_tClssPreProcInfo;

extern EMV_PARAM	g_stEmvParam;
extern EMVParamInfo		g_stEmvParamInfo;
extern Clss_TransParam	g_stClssTransParam;

//functions
//*******************************************************************************
static void AppInitDiscData_MC(void);
static void AppCreateOutcomeData_MC(int iRet);
static void AppInitPaymentData_MC(void);
static void AppSetAppType(unsigned char ucType);
static unsigned char AppGetAppType(void);
static int AppGetTornLog_MC(CLSS_TORN_LOG_RECORD *ptTornLog, int *pnTornNum);
static int AppSaveTornLog_MC(CLSS_TORN_LOG_RECORD *ptTornLog, int nTornNum);
static int AppCleanTornLog_MC(void);
static int AppLoadTornLog_MC(void);
static void SetFinalSelectAID(uchar *paucAID, uchar ucAIDLen);
static void AppSetTransPath(uchar ucTransPath);
static unsigned char AppGetTransPath(void);
static void TwoOne_app(unsigned char *pucIn, unsigned short usInlen, unsigned char *pucOut);
static int SetDETData(unsigned char *pucTag, unsigned char ucTagLen, unsigned char *pucData, unsigned char ucDataLen);
static void InitPaymentData(void);
static void InitDiscData(void);
static int AppFindMatchProID(unsigned char *pucProID, int iProIDLen);
static int AppSaveTransDataOutput_MC(uchar ucMsgFlag);
static int AppSetClss_capk(uchar index, uchar *rid, uchar kerId);
static int AppSetClss_RevLst(uchar index, uchar *rid, uchar kerId);
static void AppSetTransACType(uchar ucType);
static uchar AppGetTransACType(void);


static void Inter_DisplayMsg(int iMsg);
static void AppRemovePicc(void);
static int ClssTransInit(void);
static int ClssPreProcTxnParam(void);
static void ClssBaseParameterSet_WAVE(void);
static void ClssTermParamSet_MC(void);
static int AppSetCurAppType(unsigned char ucKernType);
static int AppTransProc_VISA(unsigned char ucTransPath, unsigned char ucACType);
static int AppTransProc_MC(uchar ucTransPath, uchar *pucACType);
static int ClssProcFlow_VISA(uchar *pucFinalData, int iFinalDataLen, Clss_PreProcInterInfo tClssProcInterInfo);
static int ClssProcFlow_MC(uchar *pucFinalData, int iFinalDataLen, Clss_PreProcInterInfo tClssProcInterInfo);
static int ClssProcFlow_ALL(void);
static int AppConv_CreateOutCome(int nRet, uchar ucACType, CLSS_OUTCOME_DATA *pstOutComeData);

static int ClssCompleteTrans_WAVE(uchar ucInOnlineResult, uchar aucRspCode[], uchar aucAuthCode[], uchar aucIAuthData[], int nIAuthDataLen,  uchar aucScript[], int nScriptLen);

//*******************************************************************************


#ifndef _WIN32


static void AppInitDiscData_MC(void)
{
	memset(&sg_tDiscretionayData, 0, sizeof(CLSS_DISC_DATA_MC));
}

static void AppCreateOutcomeData_MC(int iRet)
{
	int nErrorCode=0;

	switch(iRet)
	{
	case CLSS_USE_CONTACT:
		sg_aucErrIndication[1]=0;
		sg_aucErrIndication[3]=0;
		sg_aucErrIndication[4]=0;

		sg_aucErrIndication[1] = L2_EMPTY_CANDIDATE_LIST;//S53.13

		sg_aucUserInterReqData[0]=MI_ERROR_OTHER_CARD;//S53.14 for paypass 3.0.1 by zhoujie
		sg_aucUserInterReqData[1]=MI_IDLE;
		memcpy(sg_aucUserInterReqData+2, MSG_HOLD_TIME_VALUE, 3);
		//		nSendTransDataOutput_MC(CLSS_DATA_UIRD);//S53.14

		sg_aucOutcomeParamSet[0] = OC_END_APPLICATION;//S53.15 for paypass 3.0.1 by zhoujie
		sg_aucErrIndication[5]=MI_ERROR_OTHER_CARD;
		sg_tDiscretionayData.ucErrIndicFlg = 1;
		//		nSendTransDataOutput_MC(CLSS_DATA_OCPS | CLSS_DATA_DISD);//S53.15
		break;
	case ICC_BLOCK:
		sg_aucUserInterReqData[0]=MI_ERROR_OTHER_CARD;//s52.8 for paypass 3.0.1 by zhoujie
		sg_aucUserInterReqData[1]=MI_IDLE;
		memcpy(sg_aucUserInterReqData+2, MSG_HOLD_TIME_VALUE, 3);

		sg_aucOutcomeParamSet[0] = OC_END_APPLICATION;//s52.9 for paypass 3.0.1 by zhoujie
		sg_aucErrIndication[5]=MI_ERROR_OTHER_CARD;
		sg_tDiscretionayData.ucErrIndicFlg = 1;
		//		nSendTransDataOutput_MC(T_UIRD | T_OCPS | T_DISD);//S52.8 S52.9
		break;
	case EMV_NO_APP_PPSE_ERR:
		Clss_GetErrorCode_Entry(&nErrorCode);
		if(nErrorCode == EMV_DATA_ERR)//S52.11
		{
			sg_aucErrIndication[1]=L2_PARSING_ERROR;//S52.11 for paypass 3.0.1 by zhoujie

			sg_aucUserInterReqData[0]=MI_ERROR_OTHER_CARD;//S52.18 for paypass 3.0.1 by zhoujie
			sg_aucUserInterReqData[1]=MI_IDLE;
			memcpy(sg_aucUserInterReqData+2, MSG_HOLD_TIME_VALUE, 3);

			sg_aucOutcomeParamSet[0] = OC_END_APPLICATION;//S52.19 for paypass 3.0.1 by zhoujie
			sg_aucErrIndication[5]=MI_ERROR_OTHER_CARD;
			sg_tDiscretionayData.ucErrIndicFlg = 1;
			//			nSendTransDataOutput_MC(T_UIRD | T_OCPS | T_DISD);//S52.18 S52.19
		}
		else if (nErrorCode == EMV_RSP_ERR || nErrorCode == EMV_APP_BLOCK)
		{
			sg_aucUserInterReqData[0]=MI_ERROR_OTHER_CARD;//s52.8 for paypass 3.0.1 by zhoujie
			sg_aucUserInterReqData[1]=MI_IDLE;
			memcpy(sg_aucUserInterReqData+2, MSG_HOLD_TIME_VALUE, 3);

			sg_aucOutcomeParamSet[0] = OC_END_APPLICATION;//s52.9 for paypass 3.0.1 by zhoujie
			sg_aucErrIndication[5]=MI_ERROR_OTHER_CARD;
			sg_tDiscretionayData.ucErrIndicFlg = 1;
			//			nSendTransDataOutput_MC(T_UIRD | T_OCPS | T_DISD);//S52.8 S52.9
		}
		break;
	case EMV_NO_APP:
		sg_aucErrIndication[1] = L2_EMPTY_CANDIDATE_LIST;//S52.14

		sg_aucUserInterReqData[0]=MI_ERROR_OTHER_CARD;//S52.18 for paypass 3.0.1 by zhoujie
		sg_aucUserInterReqData[1]=MI_IDLE;
		memcpy(sg_aucUserInterReqData+2, MSG_HOLD_TIME_VALUE, 3);

		sg_aucOutcomeParamSet[0] = OC_END_APPLICATION;//S52.19 for paypass 3.0.1 by zhoujie
		sg_aucErrIndication[5]=MI_ERROR_OTHER_CARD;
		sg_tDiscretionayData.ucErrIndicFlg = 1;
		//		nSendTransDataOutput_MC(T_UIRD | T_OCPS | T_DISD);//S52.18 S52.19
		break;
	default:
		Clss_GetErrorCode_Entry(&nErrorCode);
		if(nErrorCode == EMV_NO_DATA)
		{
			sg_aucErrIndication[1] = L2_CARD_DATA_MISSING;//S1.7
		}
		else //EMV_DATA_ERR and CLSS_RESELECT_APP
		{
			sg_aucErrIndication[1] = L2_PARSING_ERROR;//S1.7
		}
		sg_aucOutcomeParamSet[0] = OC_SELECT_NEXT;
		sg_aucOutcomeParamSet[1] = OC_C;
		AppInitDiscData_MC();
		sg_tDiscretionayData.ucErrIndicFlg = 1;
		//		nSendTransDataOutput_MC(CLSS_DATA_OCPS | CLSS_DATA_DISD);//S1.8
		break;
	}
}

static void AppInitPaymentData_MC(void)//KS.2 paypass 3.0.1 by zhoujie
{
	memset(sg_aucOutcomeParamSet, 0, sizeof(sg_aucOutcomeParamSet));
	sg_aucOutcomeParamSet[0] = OC_END_APPLICATION;//for s51.13
	sg_aucOutcomeParamSet[1] = OC_NA;//s51.3
	sg_aucOutcomeParamSet[2] = OC_NA;
	sg_aucOutcomeParamSet[3] = OC_NA;
	sg_aucOutcomeParamSet[4] |= 0x10;
	sg_aucOutcomeParamSet[5] = OC_NA;
	sg_aucOutcomeParamSet[6] = 0xFF;

	memset(sg_aucUserInterReqData, 0, sizeof(sg_aucUserInterReqData));
	sg_aucUserInterReqData[0] = MI_NA;
	sg_aucUserInterReqData[1] = MI_NA;
	memcpy(sg_aucUserInterReqData+2, MSG_HOLD_TIME_VALUE, 3);

	memset(sg_aucErrIndication, 0, sizeof(sg_aucErrIndication));
	sg_aucErrIndication[5] = MI_NA;

	AppInitDiscData_MC();
}

static void AppSetAppType(unsigned char ucType)
{
	sg_ucAppType = ucType;

	switch (ucType) {
		case KERNTYPE_DEF:
			g_tTransParam.ucCurrentCLSSType[0] = CLSS_KERNEL_DEF;
			break;
		case KERNTYPE_JCB:
			g_tTransParam.ucCurrentCLSSType[0] = CLSS_KERNEL_JCB;
			break;
		case KERNTYPE_MC:
			g_tTransParam.ucCurrentCLSSType[0] = CLSS_KERNEL_MC;
			break;
		case KERNTYPE_VIS:
			g_tTransParam.ucCurrentCLSSType[0] = CLSS_KERNEL_VISA;
			break;
		case KERNTYPE_PBOC:
			g_tTransParam.ucCurrentCLSSType[0] = CLSS_KERNEL_PBOC;
			break;
		case KERNTYPE_AE:
			g_tTransParam.ucCurrentCLSSType[0] = CLSS_KERNEL_AE;
			break;
		case KERNTYPE_ZIP:
			g_tTransParam.ucCurrentCLSSType[0] = CLSS_KERNEL_ZIP;
			break;
		case KERNTYPE_FLASH:
			g_tTransParam.ucCurrentCLSSType[0] = CLSS_KERNEL_FLASH;
			break;
		case KERNTYPE_EFT:
			g_tTransParam.ucCurrentCLSSType[0] = CLSS_KERNEL_EFT;
			break;
		case KERNTYPE_RFU:
			g_tTransParam.ucCurrentCLSSType[0] = CLSS_KERNEL_RFU;
			break;
		default:
			g_tTransParam.ucCurrentCLSSType[0] = CLSS_KERNEL_DEF;
			break;
	}
}

static unsigned char AppGetAppType(void)
{
	return sg_ucAppType;
}

static int AppGetTornLog_MC(CLSS_TORN_LOG_RECORD *ptTornLog, int *pnTornNum)
{
	if (ptTornLog == NULL || pnTornNum== NULL)
	{
		return EMV_PARAM_ERR;
	}
	memcpy(ptTornLog, sg_tAppTornTransLog, sg_iAppTornLogNum * sizeof(CLSS_TORN_LOG_RECORD));
	*pnTornNum = sg_iAppTornLogNum;
	return 0;
}

static int AppSaveTornLog_MC(CLSS_TORN_LOG_RECORD *ptTornLog, int nTornNum)//save Torn Log in file
{
	int iFd=0, iRet=0;
	
	if (ptTornLog == NULL)
	{
		return EMV_PARAM_ERR;
	}

	memcpy(sg_tAppTornTransLog, ptTornLog, nTornNum*sizeof(CLSS_TORN_LOG_RECORD));
	sg_iAppTornLogNum = nTornNum;

	iFd = PdkFile_Open(PAYPASS_TORN_LOG_FILE);
	if ( iFd < 0 )
	{
		return EMV_FILE_ERR;
	}
	iRet = PdkFile_Write(iFd, (uchar *)&nTornNum, 1);
	if ( iRet != 1 )
	{
		PdkFile_Close(iRet);
		return EMV_FILE_ERR;
	}
	iRet = PdkFile_Write(iFd, (uchar *)ptTornLog, nTornNum*sizeof(CLSS_TORN_LOG_RECORD));
	if ( iRet != nTornNum*sizeof(CLSS_TORN_LOG_RECORD) )
	{
		PdkFile_Close(iRet);
		return EMV_FILE_ERR;
	}
	
	PdkFile_Close(iRet);
	return EMV_OK;
}

static int AppLoadTornLog_MC(void)//read Torn Log from file
{
	int iFd=0, iRet=0;

	iFd = PdkFile_Open(PAYPASS_TORN_LOG_FILE);
	if ( iFd < 0 )
	{
		return EMV_FILE_ERR;
	}
	memset(sg_tAppTornTransLog, 0, sizeof(sg_tAppTornTransLog));
	sg_iAppTornLogNum = 0;

	iRet = PdkFile_Read(iFd, (uchar *)&sg_iAppTornLogNum, 1);
	if ( iRet != 1 )
	{
		PdkFile_Close(iRet);
		return EMV_FILE_ERR;
	}
	if ( sg_iAppTornLogNum == 0 )
	{
		PdkFile_Close(iRet);
		return NO_TRANS_LOG;
	}
	iRet = PdkFile_Read(iFd, (uchar *)sg_tAppTornTransLog, sg_iAppTornLogNum*sizeof(CLSS_TORN_LOG_RECORD));
	if ( iRet < 0 )
	{
		PdkFile_Close(iRet);
		return EMV_FILE_ERR;
	}

	PdkFile_Close(iRet);
	return EMV_OK;	
}

static int AppCleanTornLog_MC(void)
{
	unsigned char aucBuff[8]={0};
	int iUpdatedFlg=0, iRet=0;

	GetTime(aucBuff);//  [11/18/2011 zhoujie]
	if ( sg_iAppTornLogNum == 0 ) {
		return 0;
	}
	Clss_SetTornLog_MC_MChip(sg_tAppTornTransLog, sg_iAppTornLogNum);
	iRet = Clss_CleanTornLog_MC_MChip(aucBuff, 6, 0);
	if ( iRet ) {
		return 0;
	}
	
	sg_iAppTornLogNum = 0;
	iUpdatedFlg = 0;
	memset(sg_tAppTornTransLog, 0, sizeof(sg_tAppTornTransLog));
	Clss_GetTornLog_MC_MChip(sg_tAppTornTransLog, &sg_iAppTornLogNum, &iUpdatedFlg);

	return 0;
}


// add for paypass 3.0 [12/30/2014 jiangjy]
static void SetFinalSelectAID(uchar *paucAID, uchar ucAIDLen)
{
	if ( ucAIDLen && paucAID != NULL ) {
		memcpy(sg_aucFinalAID, paucAID, ucAIDLen);
	}
	sg_ucFinalAIDLen = ucAIDLen;
}

static void AppSetTransPath(uchar ucTransPath)
{
	sg_ucTransPath = ucTransPath;

	switch (ucTransPath) {
	case CLSS_PATH_NORMAL:
		g_tTransParam.ucCurrentPathType[0] = TRANS_PATH_TYPE_CLSS_PATH_NORMAL;
		break;
	case CLSS_VISA_MSD:
		g_tTransParam.ucCurrentPathType[0] = TRANS_PATH_TYPE_CLSS_VISA_MSD;
		break;
	case CLSS_VISA_QVSDC:
		g_tTransParam.ucCurrentPathType[0] = TRANS_PATH_TYPE_CLSS_VISA_QVSDC;
		break;
	case CLSS_VISA_VSDC:
		g_tTransParam.ucCurrentPathType[0] = TRANS_PATH_TYPE_CLSS_VISA_VSDC;
		break;
	case CLSS_VISA_CONTACT:
		g_tTransParam.ucCurrentPathType[0] = TRANS_PATH_TYPE_CLSS_VISA_CONTACT;
		break;
	case CLSS_MC_MAG:
		g_tTransParam.ucCurrentPathType[0] = TRANS_PATH_TYPE_CLSS_MC_MAG;
		break;
	case CLSS_MC_MCHIP:
		g_tTransParam.ucCurrentPathType[0] = TRANS_PATH_TYPE_CLSS_MC_MCHIP;
		break;
	case CLSS_VISA_WAVE2:
		g_tTransParam.ucCurrentPathType[0] = TRANS_PATH_TYPE_CLSS_VISA_WAVE2;
		break;
	case CLSS_JCB_WAVE2:
		g_tTransParam.ucCurrentPathType[0] = TRANS_PATH_TYPE_CLSS_JCB_WAVE2;
		break;
	case CLSS_VISA_MSD_CVN17:
		g_tTransParam.ucCurrentPathType[0] = TRANS_PATH_TYPE_CLSS_VISA_MSD_CVN17;
		break;
	case CLSS_VISA_MSD_LEGACY:
		g_tTransParam.ucCurrentPathType[0] = TRANS_PATH_TYPE_CLSS_VISA_MSD_LEGACY;
		break;
	default:
		g_tTransParam.ucCurrentPathType[0] = TRANS_PATH_TYPE_CLSS_PATH_NORMAL;
		break;
	}
}

static unsigned char AppGetTransPath(void)
{
	return sg_ucTransPath;
}

static void TwoOne_app(unsigned char *pucIn, unsigned short usInlen, unsigned char *pucOut)
{
	int i=0;
	unsigned char ucTmp=0;

	for ( i = 0; i < usInlen; i += 2 ) {
		ucTmp = pucIn[i];
		if ( ucTmp > '9' ) {
			ucTmp = toupper(ucTmp) - ('A' - 0x0A);
		}
		else {
			ucTmp &= 0x0f;
		}
		ucTmp <<= 4;
		pucOut[i / 2] = ucTmp;

		ucTmp = pucIn[i + 1];
		if ( ucTmp > '9' ) {
			ucTmp = toupper(ucTmp) - ('A' - 0x0A);
		}
		else {
			ucTmp &= 0x0f;
		}
		pucOut[i / 2] += ucTmp;
	}
}

static int SetDETData(unsigned char *pucTag, unsigned char ucTagLen, unsigned char *pucData, unsigned char ucDataLen)
{
	int iRet=0;
	uchar aucBuff[256]={0},ucBuffLen=0;

	if ( (pucTag == NULL) || (pucData == NULL) ) {
		return CLSS_PARAM_ERR;
	}
	memset(aucBuff, 0, sizeof(aucBuff));
	memcpy(aucBuff, pucTag, ucTagLen);
	ucBuffLen = ucTagLen;
	aucBuff[ucBuffLen++] = ucDataLen;
	memcpy(aucBuff+ucBuffLen, pucData, ucDataLen);
	ucBuffLen += ucDataLen;
	if ( AppGetAppType() == KERNTYPE_MC ) {
		iRet = Clss_SetTLVDataList_MC(aucBuff, ucBuffLen);
	}
	return iRet;
}

static void InitPaymentData(void)//KS.2 paypass 3.0.1 by zhoujie
{
	Clss_SetTLVDataList_MC("\x9F\x7E\x01\x01", 4);//Mobile Support Indicator

	memset(sg_aucOutcomeParamSet, 0, sizeof(sg_aucOutcomeParamSet));
	sg_aucOutcomeParamSet[0] = OC_END_APPLICATION;//for s51.13
	sg_aucOutcomeParamSet[1] = OC_NA;//s51.3
	sg_aucOutcomeParamSet[2] = OC_NA;
	sg_aucOutcomeParamSet[3] = OC_NA;
	sg_aucOutcomeParamSet[4] |= 0x10;
	sg_aucOutcomeParamSet[5] = OC_NA;
	sg_aucOutcomeParamSet[6] = 0xFF;

	memset(sg_aucUserInterReqData, 0, sizeof(sg_aucUserInterReqData));
	sg_aucUserInterReqData[0] = MI_NA;
	sg_aucUserInterReqData[1] = MI_NA;
	memcpy(sg_aucUserInterReqData+2, MSG_HOLD_TIME_VALUE, 3);

	memset(sg_aucErrIndication, 0, sizeof(sg_aucErrIndication));
	sg_aucErrIndication[5] = MI_NA;

	InitDiscData();
	//	gl_ucTornLogRecordExist = 0;
}

static void InitDiscData(void)//Initialize Discretionary Data by zhoujie
{
	memset(&sg_tDiscretionayData,0,sizeof(sg_tDiscretionayData));
}

static int AppFindMatchProID(unsigned char *pucProID, int iProIDLen)
{
	int i=0, iRet=0, iFd=0;
	EMV_APPLIST tEMVAPP;

	if ( pucProID == NULL ) {
		return EMV_PARAM_ERR;
 	} else {
 		iFd = PdkFile_Open(EMV_APP_LIST_FILE);
		if ( iFd < 0 ) {
			return iFd;
		}
		
		for ( i=0; i < g_stEmvParamInfo.usAidNum; i++ ) {
			memset(&tEMVAPP, 0, sizeof(EMV_APPLIST));
			iRet = PdkFile_Read(iFd, (unsigned char *)&tEMVAPP, sizeof(EMV_APPLIST));
#ifdef DEBUG_
		AppLog("[AppFindMatchProID] EMVGetApp = %d \n", iRet);
#endif
			if ( iRet != sizeof(EMV_APPLIST) ) {
				break;
			}		
			iRet = Clss_AddAidList_Entry(tEMVAPP.AID, tEMVAPP.AidLen, tEMVAPP.SelFlag, KERNTYPE_DEF);
#ifdef DEBUG_
		AppLog("[AppFindMatchProID] Clss_AddAidList_Entry = %d \n", iRet);
#endif
			if ( iRet != EMV_OK ) {
				continue;
			}
			memset(&sg_tProgInfo, 0, sizeof(Clss_ProgramID));
		 	sg_tProgInfo.ulTermFLmt = sg_tClssPreProcInfo.ulTermFLmt;
		 	sg_tProgInfo.ulRdClssTxnLmt = sg_tClssPreProcInfo.ulRdClssTxnLmt;
		 	sg_tProgInfo.ulRdCVMLmt = sg_tClssPreProcInfo.ulRdCVMLmt;
		 	sg_tProgInfo.ulRdClssFLmt =  sg_tClssPreProcInfo.ulRdClssFLmt;	
			memcpy(sg_tProgInfo.aucProgramId, pucProID, 17);
			sg_tProgInfo.ucPrgramIdLen = iProIDLen;
		 	sg_tProgInfo.ucAmtZeroNoAllowed = 0;
		 	sg_tProgInfo.ucStatusCheckFlg = sg_tClssPreProcInfo.ucStatusCheckFlg;
		 	sg_tProgInfo.ucTermFLmtFlg = sg_tClssPreProcInfo.ucTermFLmtFlg;
		 	sg_tProgInfo.ucRdClssTxnLmtFlg = sg_tClssPreProcInfo.ucRdClssTxnLmtFlg;
		 	sg_tProgInfo.ucRdCVMLmtFlg = sg_tClssPreProcInfo.ucRdCVMLmtFlg;
		 	sg_tProgInfo.ucRdClssFLmtFlg = sg_tClssPreProcInfo.ucRdClssFLmtFlg;
		}
	}

	PdkFile_Close(iFd);
	return iRet;
}

int ClssSendTransDataOutput_MC(uchar ucMsgFlag)
{
	return AppSaveTransDataOutput_MC(ucMsgFlag);
}

uchar *App_GetFirstTLV(uchar *dat, uchar *datend, uchar *pucTag, uint *punLen)//  [1/9/2013 ZhouJie]
{
	uint i, j, unTempDataLen=0;
	uchar ucTagLen=0;
	uchar *pucDataStart=NULL, *pucDataEnd=NULL, *pucTempTag=NULL;
	if (dat == NULL || datend == NULL || pucTag == NULL || punLen == NULL)
	{
		return NULL;
	}
	pucDataStart = dat;
	pucDataEnd = datend;
	while (pucDataStart < pucDataEnd)
	{
		ucTagLen=0;
		pucTempTag = pucDataStart++;
		ucTagLen++;
		if (pucTempTag[0] == 0x00)
		{
			continue;
		}
		if ((pucTempTag[0] & 0x1F) == 0x1F)
		{
			ucTagLen++;
			while (pucDataStart < pucDataEnd && (*pucDataStart & 0x80))
			{
				pucDataStart++;
				ucTagLen++;
			}
			pucDataStart++;
		}
		if (pucDataStart >= pucDataEnd) // no length // G06-9260[11/24/2011 zhoujie]
		{
			return NULL;
		}
		if (*pucDataStart & 0x80)
		{
			i = (*pucDataStart & 0x7F);
			if (pucDataStart + i > pucDataEnd)
			{
				return NULL;
			}
			pucDataStart++;
			for (j = 0; j < i; j++)
			{
				unTempDataLen <<= 8;
				unTempDataLen += *pucDataStart++;
			}
		}
		else
		{
			unTempDataLen = *pucDataStart++;
		}
		memcpy(pucTag, pucTempTag, ucTagLen);
		*punLen = unTempDataLen;
		return pucDataStart;
	}
	return NULL;
}

uchar AppGetTagLen(uchar *pucTag)
{
	uchar ucTagLen=0;
	int i;
	uchar szTmpTag[4];

	if (pucTag == NULL)
	{
		return 0;
	}
	memset (szTmpTag, 0, sizeof(szTmpTag));
	for (i=0; i<4; i++)
	{
		if (pucTag[i] != 0x00)
		{
			memcpy(szTmpTag, &pucTag[i], 4-i);
			break;
		}
	}
	ucTagLen = 4-i;

	return ucTagLen;
}

unsigned char *App_SearchTLV(int DolList, unsigned char *pucTag, unsigned char *dat, unsigned char *datend, int *nLen)
{
	uint unTempLen;
	uchar aucTempTag[4];
	uchar *pucValue=NULL;
	uchar *pucDataStart, *pucDataEnd;
	if (dat == NULL || datend == NULL || pucTag == NULL)
	{
		return NULL;
	}
	memset(aucTempTag, 0, sizeof(aucTempTag));//for three byte of tag
	pucDataStart = dat;
	pucDataEnd = datend;
	while (pucDataStart < pucDataEnd) 
	{
		if (*pucDataStart == 0x00)
		{
			pucDataStart++;
			continue;
		}
		pucValue = App_GetFirstTLV(pucDataStart, pucDataEnd, aucTempTag, &unTempLen);
		if (pucValue == NULL)//can't find a TLV
		{
			return NULL;
		}
		if (!memcmp(aucTempTag, pucTag, AppGetTagLen(pucTag))) //successful
		{
			if (nLen != NULL) 
			{
				*nLen = unTempLen;
			}
			return pucValue;
		}
		pucDataStart = pucValue;
		if (aucTempTag[0] & 0x20) 
		{
			continue;
		}
		if (DolList) 
		{
			continue;
		}
		pucDataStart += unTempLen;//continue search next TLV
	}
	return NULL;
}

static int AppSaveTransDataOutput_MC(uchar ucMsgFlag)
{
	uint unLen=0, unBuffLen=0;
	uchar aucBuff[1024]={0};
	
	if(ucMsgFlag & CLSS_DATA_OCPS)
	{
		Clss_GetTLVDataList_MC("\xDF\x81\x29", 3, sizeof(sg_aucOutcomeParamSet), sg_aucOutcomeParamSet, &unLen);
	}
	if(ucMsgFlag & CLSS_DATA_UIRD)
	{
		Clss_GetTLVDataList_MC("\xDF\x81\x16", 3, sizeof(sg_aucUserInterReqData), sg_aucUserInterReqData, &unLen);
	}
	if(ucMsgFlag & CLSS_DATA_DISD)
	{
		Clss_GetTLVDataList_MC("\xDF\x81\x15", 3, sizeof(sg_aucErrIndication), sg_aucErrIndication, &unLen);
		memset(aucBuff, 0, sizeof(aucBuff));
		Clss_GetTLVDataList_MC("\xFF\x81\x06", 3, sizeof(aucBuff), aucBuff, &unBuffLen);
		if (App_SearchTLV(0, (uchar *)"\x9F\x42", aucBuff, aucBuff+unBuffLen, &unLen))
		{
			if (unLen)
			{
				sg_tDiscretionayData.ucAppCurrCodeFlg = APP_TAG_EXIST_WITHVAL;
			}
			else
			{
				sg_tDiscretionayData.ucAppCurrCodeFlg = APP_TAG_EXIST_NOVAL;
			}
		}
		else
		{
			sg_tDiscretionayData.ucAppCurrCodeFlg = APP_TAG_NOT_EXIST;
		}
		if (App_SearchTLV(0, (uchar *)"\xDF\x81\x04", aucBuff, aucBuff+unBuffLen, &unLen))
		{
			if (unLen)
			{
				sg_tDiscretionayData.ucBalBeforeGACFlg = APP_TAG_EXIST_WITHVAL;
			}
			else
			{
				sg_tDiscretionayData.ucBalBeforeGACFlg = APP_TAG_EXIST_NOVAL;
			}
		}
		else
		{
			sg_tDiscretionayData.ucBalBeforeGACFlg = APP_TAG_NOT_EXIST;
		}
		if (App_SearchTLV(0, (uchar *)"\xDF\x81\x05", aucBuff, aucBuff+unBuffLen, &unLen))
		{
			if (unLen)
			{
				sg_tDiscretionayData.ucBalAfterGACFlg = APP_TAG_EXIST_WITHVAL;
			}
			else
			{
				sg_tDiscretionayData.ucBalAfterGACFlg = APP_TAG_EXIST_NOVAL;
			}
		}
		else
		{
			sg_tDiscretionayData.ucBalAfterGACFlg = APP_TAG_NOT_EXIST;
		}
		if (App_SearchTLV(0, (uchar *)"\xDF\x81\x02", aucBuff, aucBuff+unBuffLen, &unLen))
		{
			if (unLen)
			{
				sg_tDiscretionayData.ucDSSum3Flg = APP_TAG_EXIST_WITHVAL;
			}
			else
			{
				sg_tDiscretionayData.ucDSSum3Flg = APP_TAG_EXIST_NOVAL;
			}
		}
		else
		{
			sg_tDiscretionayData.ucDSSum3Flg = APP_TAG_NOT_EXIST;
		}
		if (App_SearchTLV(0, (uchar *)"\xDF\x81\x0B", aucBuff, aucBuff+unBuffLen, &unLen))
		{
			if (unLen)
			{
				sg_tDiscretionayData.ucDSSumStFlg = APP_TAG_EXIST_WITHVAL;
			}
			else
			{
				sg_tDiscretionayData.ucDSSumStFlg = APP_TAG_EXIST_NOVAL;
			}
		}
		else
		{
			sg_tDiscretionayData.ucDSSumStFlg = APP_TAG_NOT_EXIST;
		}
		if (App_SearchTLV(0, (uchar *)"\xDF\x81\x15", aucBuff, aucBuff+unBuffLen, &unLen))
		{
			if (unLen)
			{
				Clss_GetTLVDataList_MC((uchar*)"\xDF\x81\x15", 3, sizeof(sg_aucErrIndication), sg_aucErrIndication, &unLen);
				sg_tDiscretionayData.ucErrIndicFlg = APP_TAG_EXIST_WITHVAL;
			}
			else
			{
				sg_tDiscretionayData.ucErrIndicFlg = APP_TAG_EXIST_NOVAL;
			}
		}
		else
		{
			sg_tDiscretionayData.ucErrIndicFlg = APP_TAG_NOT_EXIST;
		}
		if (App_SearchTLV(0, (uchar *)"\xDF\x81\x0E", aucBuff, aucBuff+unBuffLen, &unLen))
		{
			if (unLen)
			{
				sg_tDiscretionayData.ucPostGACPutDataStFlg = APP_TAG_EXIST_WITHVAL;
			}
			else
			{
				sg_tDiscretionayData.ucPostGACPutDataStFlg = APP_TAG_EXIST_NOVAL;
			}
		}
		else
		{
			sg_tDiscretionayData.ucPostGACPutDataStFlg = APP_TAG_NOT_EXIST;
		}
		if (App_SearchTLV(0, (uchar *)"\xDF\x81\x0F", aucBuff, aucBuff+unBuffLen, &unLen))
		{
			if (unLen)
			{
				sg_tDiscretionayData.ucPreGACPutDataStFlg = APP_TAG_EXIST_WITHVAL;
			}
			else
			{
				sg_tDiscretionayData.ucPreGACPutDataStFlg = APP_TAG_EXIST_NOVAL;
			}
		}
		else
		{
			sg_tDiscretionayData.ucPreGACPutDataStFlg = APP_TAG_NOT_EXIST;
		}
		if (App_SearchTLV(0, (uchar *)"\x9F\x6E", aucBuff, aucBuff+unBuffLen, &unLen))
		{
			if (unLen)
			{
				sg_tDiscretionayData.ucThirdPartyDataFlg = APP_TAG_EXIST_WITHVAL;
			}
			else
			{
				sg_tDiscretionayData.ucThirdPartyDataFlg = APP_TAG_EXIST_NOVAL;
			}
		}
		else
		{
			sg_tDiscretionayData.ucThirdPartyDataFlg = APP_TAG_NOT_EXIST;
		}
		if (App_SearchTLV(0, (uchar *)"\xFF\x81\x01", aucBuff, aucBuff+unBuffLen, &unLen))
		{
			if (unLen)
			{
				sg_tDiscretionayData.ucTornRecordFlg = APP_TAG_EXIST_WITHVAL;
			}
			else
			{
				sg_tDiscretionayData.ucTornRecordFlg = APP_TAG_EXIST_NOVAL;
			}
		}
		else
		{
			sg_tDiscretionayData.ucTornRecordFlg = APP_TAG_NOT_EXIST;
		}
		if (App_SearchTLV(0, (uchar *)"\xDF\x81\x2A", aucBuff, aucBuff+unBuffLen, &unLen))
		{
			if (unLen)
			{
				sg_tDiscretionayData.ucDDCardTrack1Flg = APP_TAG_EXIST_WITHVAL;
			}
			else
			{
				sg_tDiscretionayData.ucDDCardTrack1Flg = APP_TAG_EXIST_NOVAL;
			}
		}
		else
		{
			sg_tDiscretionayData.ucDDCardTrack1Flg = APP_TAG_NOT_EXIST;
		}
		if (App_SearchTLV(0, (uchar *)"\xDF\x81\x2B", aucBuff, aucBuff+unBuffLen, &unLen))
		{
			if (unLen)
			{
				sg_tDiscretionayData.ucDDCardTrack2Flg = APP_TAG_EXIST_WITHVAL;
			}
			else
			{
				sg_tDiscretionayData.ucDDCardTrack2Flg = APP_TAG_EXIST_NOVAL;
			}
		}
		else
		{
			sg_tDiscretionayData.ucDDCardTrack2Flg = APP_TAG_NOT_EXIST;
		}
	}
	return EMV_OK;
}

static int AppSetClss_capk(uchar ucKeyIndex, uchar *pucRid, uchar ucKernelId)
{
	int i = 0, iRet = -1;
	//TODO for test
/*
	for(i=0; i<MAX_KEY_NUM; i++)
	{
		if(memcmp(glCAPKeyList[i].RID, rid, 5) != 0)
		{
			continue;
		}
		if(index != glCAPKeyList[i].KeyID)
		{
			continue;
		}

		else if(kerId == KERNTYPE_VIS)
		{
			iRet = Clss_AddCAPK_Wave(&glCAPKeyList[i]);
		}
		else if(kerId == KERNTYPE_MC)
		{
		    iRet = Clss_AddCAPK_MC_MChip(&glCAPKeyList[i]);
		}
		else
		{
			return ERR_TRAN_FAIL;
		}
	}
*/
	EMV_CAPK pstEmvCapk;

	iRet = EMVLoadSpecificCapk(pucRid, ucKeyIndex, &pstEmvCapk);
#ifdef DEBUG_
		AppLog("[AppSetClss_capk] EMVLoadSpecificCapk = %d \n", iRet);
#endif
	if ( iRet == 0 ) {
		if ( ucKernelId == KERNTYPE_VIS ) {
			iRet = Clss_AddCAPK_Wave(&pstEmvCapk);
#ifdef DEBUG_
			AppLog("[AppSetClss_capk] Clss_AddCAPK_Wave = %d \n", iRet);
#endif
		}
		else if ( ucKernelId == KERNTYPE_MC ) {
		    	iRet = Clss_AddCAPK_MC_MChip(&pstEmvCapk);
#ifdef DEBUG_
			AppLog("[AppSetClss_capk] Clss_AddCAPK_MC_MChip = %d \n", iRet);
#endif
		}
		else {
			return -1;
		}
	}

	return 0;
}


static int AppSetClss_RevLst(uchar index, uchar *rid, uchar kerId)
{
	int iRet = 0;
	EMV_REVOCLIST tRevocList;

// 	memset(ucAid, 0, sizeof(ucAid));
// 	PubAsc2Bcd(rid, strlen(rid), ucAid);
	memcpy(tRevocList.ucRid, rid, 5);
	tRevocList.ucIndex = index;
	memcpy(tRevocList.ucCertSn, "\x00\x07\x11", 3);

	if (kerId == KERNTYPE_VIS)
	{
		Clss_AddRevocList_Wave(&tRevocList);
	}
//	else		//modified by kevinliu 2015/10/19
	else if (kerId == KERNTYPE_MC)
	{
		Clss_AddRevocList_MC_MChip(&tRevocList);
	}
	else
	{
		return TRANS_EMV_NOT_FOUND;
	}

	return EMV_OK;
}

static void AppSetTransACType(uchar ucType)
{
	sg_ucACType = ucType;
}

static uchar AppGetTransACType(void)
{
	return sg_ucACType;
}

static void Inter_DisplayMsg(int iMsg)
{
	switch ( iMsg ) {
	case MSG_CLEAR_DISPLAY:
		break;
	case MSG_CARD_READ_OK:
		Beep();
		break;
	case MSG_REMOVE_CARD:
		Beep();
		break;
	case ICC_BLOCK:
		Beep();
		break;
	case MSG_TRY_AGAIN:
		Beep();
		break;
	case MSG_SEE_PHONE:
		Beep();
		break;
	case MSG_APPROVED:
		Beep();
		break;
	case MSG_DECLINED:
		Beep();
		break;
	case MSG_APPROVED_SIGN:
		Beep();
		break;
	case MSG_OTHER_CARD:
		Beep();
		break;
	case MSG_INSERT_CARD:
		Beep();
		break;
	case MSG_AUTHORISING:
		Beep();
		break;
	case MSG_TAP_CARD_AGAIN:
		Beep();
		break;
	case MSG_TAP_CARD_WITH_AMOUNT:
		Beep();
		break;
	case MSG_TAP_CARD_WITH_BALANCE:
		Beep();
		break;
	case MSG_TRY_ANOTHER_INTERFACE:
		Beep();
		break;
	case MSG_END_APPLICATION:
		Beep();
		break;
	default:
		break;
	}
	//PubWaitKey(30);//delay
	DelayMs(200);
}

static void AppRemovePicc(void)
{
	uchar ucRet = 0; 
	int i = 0;

	Beef(0,100); // Added by ZhangYuan 2016-10-18 
	//  [4/11/2011 yingl]
	ucRet = PiccRemove('r', 0);
	if ((ucRet == 0) || (ucRet == 1)) 
	{  
		PiccClose();
		return;
	}

	i = 0;
	while (ucRet) 
	{
		ucRet = PiccRemove('r', 0); 
		if ((ucRet == 2) || (ucRet == 3))
		{
			break;
		} 
		else
		{
			if (i == 0) {
				//TODO Display remove card here.
				ScrCls();
				PubDispString("PLS REMOVE CARD", 0|DISP_LINE_LEFT);
				Beep();
				i++;
			}
		}
	}

	PiccClose();
}

static int ClssTransInit(void)
{
	int i=0, iRet=0, iFd=0;
	EMV_APPLIST tEMVAPP;

	//added by Kevin Liu 20160902
	g_tTransParam.ucCurrentTxnType[0] = TRANS_TYPE_CONTACTLESS;

	Clss_CoreInit_Entry();
	
	Clss_DelAllAidList_Entry();
	Clss_DelAllPreProcInfo();

/*
	memset(glCAPKeyList, 0, sizeof(glCAPKeyList));
	//read all CAPK, save into memory added by kevinliu
	for(i=0; i < glSysParam.uiCapkNum; i++) {
		iRet = ReadCAPKFile(i, &glCAPKeyList[i]);
	}
*/
	//TODO for testing

	iFd = PdkFile_Open(EMV_APP_LIST_FILE);
	if ( iFd < 0 ) {
		return iFd;
	}

	for ( i=0; i < g_stEmvParamInfo.usAidNum; i++ ) {
		memset(&tEMVAPP, 0, sizeof(EMV_APPLIST));
		iRet = PdkFile_Read(iFd, (unsigned char *)&tEMVAPP, sizeof(EMV_APPLIST));
#ifdef DEBUG_
		AppLog("[ClssTransInit] PdkFile_Read = %d \n", iRet);
#endif
		if ( iRet != sizeof(EMV_APPLIST) ) {
			break;
		}

		iRet = Clss_AddAidList_Entry(tEMVAPP.AID, tEMVAPP.AidLen, tEMVAPP.SelFlag, KERNTYPE_DEF);
#ifdef DEBUG_
		AppLog("[ClssTransInit] Clss_AddAidList_Entry = %d \n", iRet);
#endif
		if ( iRet != EMV_OK ) {
			continue;
		}

		memset(&sg_tClssPreProcInfo, 0, sizeof(Clss_PreProcInfo));
		sg_tClssPreProcInfo.ulTermFLmt = 5000;	//Terminal Offline limit
		sg_tClssPreProcInfo.ulRdClssTxnLmt = 100000;	//Reader contactless transaction limit
		sg_tClssPreProcInfo.ulRdCVMLmt = 3000;	//Reader CVM limit
		sg_tClssPreProcInfo.ulRdClssFLmt = 5000;	//Reader contactless Offline limit

		memcpy(sg_tClssPreProcInfo.aucAID, tEMVAPP.AID, tEMVAPP.AidLen);
		sg_tClssPreProcInfo.ucAidLen = tEMVAPP.AidLen;

		sg_tClssPreProcInfo.ucKernType = KERNTYPE_DEF;

		sg_tClssPreProcInfo.ucCrypto17Flg = 1;
		sg_tClssPreProcInfo.ucZeroAmtNoAllowed = 0;
		sg_tClssPreProcInfo.ucStatusCheckFlg = 0;
		memcpy(sg_tClssPreProcInfo.aucReaderTTQ, "\x36\x00\x80\x00", 4);

		sg_tClssPreProcInfo.ucTermFLmtFlg = 1;
		sg_tClssPreProcInfo.ucRdClssTxnLmtFlg = 1;
		sg_tClssPreProcInfo.ucRdCVMLmtFlg = 1;
		sg_tClssPreProcInfo.ucRdClssFLmtFlg=1;
		Clss_SetPreProcInfo_Entry(&sg_tClssPreProcInfo);
	}

	PdkFile_Close(iFd);
	return EMV_OK;
}

static int ClssPreProcTxnParam(void)
{
	int iRet=0;

	//pre-process
	memset(&sg_tClssTransParam, 0, sizeof(Clss_TransParam));
	//TODO for testing
	memcpy(&sg_tClssTransParam, &g_stClssTransParam, sizeof(Clss_TransParam));
/*
	sg_tClssTransParam.ulAmntAuth = atol((char *)g_stClssTransParam.ulAmntAuth);
	sg_tClssTransParam.ulAmntOther = atol((char *)g_stClssTransParam.ulAmntOther);
	sg_tClssTransParam.ucTransType = g_stClssTransParam.ucTransType;
	PubAsc2Bcd(g_stClssTransParam.aucTransDate, 6, sg_tClssTransParam.aucTransDate);
	PubAsc2Bcd(glProcInfo.stTranLog.szDateTime+8, 6, sg_tClssTransParam.aucTransTime);
	sg_tClssTransParam.ulTransNo = glProcInfo.stTranLog.ulSTAN;
*/
	iRet = Clss_PreTransProc_Entry(&sg_tClssTransParam);
	//returns EMV_OK	CLSS_PARAM_ERR		CLSS_USE_CONTACT
	if ( iRet != EMV_OK ) {
		return iRet;
	}
	return EMV_OK;

}

static void ClssBaseParameterSet_WAVE(void)
{
	Clss_ReaderParam tClssParam;
	Clss_VisaAidParam tVisaAidParam;

	Clss_GetReaderParam_Wave(&tClssParam);
	memcpy(tClssParam.aucTmCap,"\xE0\xE1\xC8",3);
	memcpy(tClssParam.aucTmCapAd,"\xE0\x00\xF0\xA0\x01",5);
	tClssParam.ucTmType = 0x22;

	memcpy(tClssParam.aucTmCntrCode, g_stEmvParam.CountryCode, 2);
	memcpy(tClssParam.aucTmRefCurCode, g_stEmvParam.ReferCurrCode, 2);
	memcpy(tClssParam.aucTmTransCur, g_stEmvParam.TransCurrCode, 2);
	Clss_SetReaderParam_Wave(&tClssParam);
// move [1/8/2015 jiangjy]
// 	memset(&ClssVisaAidParam,0,sizeof(Clss_VisaAidParam));
// 	ClssVisaAidParam.ulTermFLmt = 0;
// 	Clss_SetVisaAidParam_Wave(&ClssVisaAidParam);

	memset(&tVisaAidParam,0,sizeof(Clss_VisaAidParam));
	tVisaAidParam.ucCvmReqNum = 2;
	tVisaAidParam.aucCvmReq[0] = RD_CVM_REQ_SIG;
	tVisaAidParam.aucCvmReq[1] = RD_CVM_REQ_ONLINE_PIN;

	tVisaAidParam.ucDomesticOnly = 0x00; // 01(default):only supports domestic cl transaction
	tVisaAidParam.ucEnDDAVerNo = 0;// fDDA ver 00 & 01 are all supported
	tVisaAidParam.ulTermFLmt = 5000;
	Clss_SetVisaAidParam_Wave(&tVisaAidParam);
}

static void ClssTermParamSet_MC(void)//for paypass
{
	unsigned char aucBuff[50]={0},aucAmount[6]={0};

	Clss_SetTLVDataList_MC("\x5F\x57\x00", 3);//Account type no value
	Clss_SetTLVDataList_MC("\x9F\x01\x00", 3);//Acquire id no value
	Clss_SetTLVDataList_MC("\x9F\x1E\x08\x11\x22\x33\x44\x55\x66\x77\x88", 11);//Interface Device Serial Number with any value
	Clss_SetTLVDataList_MC("\x9F\x15\x02\x00\x01", 5);//Merchant Category Code with any value
	Clss_SetTLVDataList_MC("\x9F\x16\x00", 3);//Merchant Identifier no value
	Clss_SetTLVDataList_MC("\x9F\x4E\x00", 3);//Merchant Name and Location no value
	Clss_SetTLVDataList_MC("\x9F\x33\x00", 3);//terminal capability no value
	Clss_SetTLVDataList_MC("\x9F\x1C\x00", 3);//terminal id no value

	Clss_SetTagPresent_MC("\xDF\x81\x04", 0);//Balance Before GAC
	Clss_SetTagPresent_MC("\xDF\x81\x05", 0);//Balance After GAC
	Clss_SetTagPresent_MC("\xDF\x81\x2D", 0);//Message Hold Time
	Clss_SetTLVDataList_MC("\x9F\x7E\x00", 3);//Mobile Support Indicator

	Clss_SetTLVDataList_MC("\xDF\x81\x08\x00", 4);//DS AC Type
	Clss_SetTLVDataList_MC("\xDF\x60\x00", 3);//DS Input (Card)
	Clss_SetTLVDataList_MC("\xDF\x81\x09\x00", 4);//DS Input (Term)
	Clss_SetTLVDataList_MC("\xDF\x62\x00", 3);//DS ODS Info
	Clss_SetTLVDataList_MC("\xDF\x81\x0A\x00", 4);//DS ODS Info For Reader
	Clss_SetTLVDataList_MC("\xDF\x63\x00", 3);//DS ODS Term

	Clss_SetTagPresent_MC("\xDF\x81\x10", 0);//Proceed To First Write Flag Tag not present
	Clss_SetTagPresent_MC("\xDF\x81\x12", 0);//Tags To Read Tag not present
	Clss_SetTagPresent_MC("\xFF\x81\x02", 0);//Tags To Write Before Gen AC
	Clss_SetTagPresent_MC("\xFF\x81\x03", 0);//Tags To Write After Gen AC
	Clss_SetTagPresent_MC("\xDF\x81\x27", 0);//Time Out Value Tag not present

	//modified by kevin liu 20160628
	SetDETData("\x9F\x5C", 2, "\x7A\x45\x12\x3E\xE5\x9C\x7F\x40", 8);//DS Requested Operator ID
	Clss_SetTagPresent_MC("\xDF\x81\x0D", 0);
	Clss_SetTagPresent_MC("\x9F\x70", 0);
	Clss_SetTagPresent_MC("\x9F\x75", 0);

	SetDETData("\x9F\x09", 2, "\x00\x02", 2);
	SetDETData("\x9F\x40", 2, "\x00\x00\x00\x00\x00", 5);
	SetDETData("\xDF\x81\x17", 3, "\xE0", 1);//card data input capability
	SetDETData("\xDF\x81\x18", 3, "\x60", 1);//ONLINE PIN :40 /SIG:20
	SetDETData("\xDF\x81\x19", 3, "\x08", 1);//NO CVM
	SetDETData("\xDF\x81\x1F", 3, "\xC8", 1);//08:CDA      //40:DDA 
	SetDETData("\xDF\x81\x1A", 3, "\x9F\x6A\x04",3);//Default UDOL
	SetDETData("\x9F\x6D", 2, "\x00\x01", 2);
	SetDETData("\xDF\x81\x1E", 3, "\x20", 1); //Modified by Kevin Liu 20160801
	SetDETData("\xDF\x81\x2C", 3, "\x00", 1);

	memset(aucAmount, 0, sizeof(aucAmount));
	memset(aucBuff, 0, sizeof(aucBuff));

	sprintf((char *)aucBuff, "%012ld", sg_tClssTransParam.ulAmntAuth);

	TwoOne_app(aucBuff, 12, aucAmount);
	SetDETData("\x9F\x02", 2, aucAmount, 6);

	memset(aucAmount, 0, sizeof(aucAmount));
	memset(aucBuff, 0, sizeof(aucBuff));

	sprintf((char *)aucBuff, "%012ld", sg_tClssTransParam.ulAmntOther);

	TwoOne_app(aucBuff, 12, aucAmount);
	SetDETData("\x9F\x03", 2, aucAmount, 6);

	SetDETData("\x9C", 1, &sg_tClssTransParam.ucTransType, 1);
	SetDETData("\x9A", 1, sg_tClssTransParam.aucTransDate, 3);
	SetDETData("\x9F\x21", 2, sg_tClssTransParam.aucTransTime, 3);

	SetDETData("\xDF\x81\x20", 3, "\x04\x00\x00\x00\x00", 5);
	SetDETData("\xDF\x81\x21", 3, "\x04\x00\x00\x00\x00", 5);
	SetDETData("\xDF\x81\x22", 3, "\xF8\x50\xAC\xF8\x00", 5);//TAC online
	
	//[1/9/2015 jiangjy] limit  set for AID
	SetDETData("\xDF\x81\x23", 3, "\x00\x00\x00\x00\x50\x00", 6);//floor limit
	SetDETData("\xDF\x81\x24", 3, "\x00\x00\x00\x10\x00\x00", 6);
	SetDETData("\xDF\x81\x25", 3, "\x00\x00\x00\x10\x00\x00", 6);
	SetDETData("\xDF\x81\x26", 3, "\x00\x00\x00\x00\x30\x00", 6);//cvm limit

	SetDETData("\x9F\x35", 2, "\x22", 1);

	Clss_SetTagPresent_MC("\xDF\x81\x30", 0);
	SetDETData("\xDF\x81\x1C", 3, "\x00\x00", 2);
	SetDETData("\xDF\x81\x1D", 3, "\x00", 1);
	SetDETData("\xDF\x81\x0C", 3, "\x02", 1);
	Clss_SetTagPresent_MC("\xDF\x81\x2D", 0);
	SetDETData("\x9F\x1A", 2, g_stEmvParam.CountryCode, 2);
	SetDETData("\x5F\x2A", 2, g_stEmvParam.TransCurrCode, 2);
	if ( sg_ucFinalAIDLen == 0 ) {
		return;
	}
	if ( memcmp(sg_aucFinalAID, "\xA0\x00\x00\x00\x04\x10\x10",7) == 0 ) {
		//MCD
		SetDETData("\xDF\x81\x1B", 3, "\x20", 1);  
		//Tag 9F1D set based on definition
//		Clss_AddProprietaryData_MC(CombiTLVElement((uchar*)"\x9F\x1D", 2, (uchar *)"\x6C\xF8\x00\x00\x00\x00\x00\x00", 8, CLSS_SRC_TM, 0));
	}
	else if ( memcmp(sg_aucFinalAID,  "\xA0\x00\x00\x00\x04\x30\x60", 7) == 0 ) {
		//Mestro  NO MAG-STRIPE 
		SetDETData("\xDF\x81\x1B", 3, "\xA0", 1);
		//Tag 9F1D
//		Clss_AddProprietaryData_MC(CombiTLVElement((uchar*)"\x9F\x1D", 2, (uchar *)"\x40\xF8\x80\x00\x00\x00\x00\x00", 8, CLSS_SRC_TM, 0));
	}
}


static int AppSetCurAppType(unsigned char ucKernType)
{
	int iRet=0;

	if ( ucKernType == KERNTYPE_VIS ) {
		AppSetAppType(KERNTYPE_VIS);
		Clss_CoreInit_Wave();
	}
	else if ( ucKernType == KERNTYPE_MC ) {
		AppSetAppType(KERNTYPE_MC);
		Clss_CoreInit_MC(1);
		Clss_SetParam_MC("\x04", 1);// set the timer number for kernel [1/21/2014 ZhouJie]
		AppCleanTornLog_MC();
	}
	else {
		return CLSS_TERMINATE;
	}
	return EMV_OK;
}


static int AppTransProc_VISA(unsigned char ucTransPath, unsigned char ucACType)
{
	int iRet=0;
	int iTempLen=0;
	unsigned char ucPkIndex=0;
	unsigned char ucDDAFailFlg=0;

	switch ( ucTransPath ) {
	case CLSS_VISA_MSD:
	case CLSS_VISA_MSD_CVN17:
	case CLSS_VISA_MSD_LEGACY:
		break;
	case CLSS_VISA_QVSDC:
		AppRemovePicc();
		iRet = Clss_ProcRestric_Wave();
#ifdef DEBUG_
		AppLog("Clss_ProcRestric_Wave = %d ", iRet);
#endif
		if ( iRet ) {
			return iRet;
		}

		if (ucACType == AC_TC && sg_tClssTransParam.ucTransType != 0x20)//REFUND
		{
			Clss_DelAllRevocList_Wave();
			Clss_DelAllCAPK_Wave();

			if ( Clss_GetTLVData_Wave(0x8F, &ucPkIndex,  &iTempLen) == 0)  
			{
				//if (AppConv_GetTLVData(0x9F06, aucAid, &nTempLen) == 0)//get aid
				{
					AppSetClss_capk(ucPkIndex, sg_aucFinalAID, sg_ucAppType);// capk
					AppSetClss_RevLst(ucPkIndex, sg_aucFinalAID, sg_ucAppType);
				}

				iRet = Clss_CardAuth_Wave(&ucACType, &ucDDAFailFlg);//capk
#ifdef DEBUG_
		AppLog("Clss_CardAuth_Wave = %d ", iRet);
#endif
				if (iRet != 0) 
				{					
					if (iRet != CLSS_USE_CONTACT) 
					{
						iRet =  CLSS_TERMINATE;	
					}
				}
				else
				{
					if (ucDDAFailFlg == 1) 
					{
						iRet =  CLSS_TERMINATE;							
					}
					else
					{
						//modified by Kevin Liu 20160621
//						Inter_DisplayMsg(MSG_APPROVED);
					}
				}
			}
			else
			{
				if (ucACType == AC_ARQC || ucACType == AC_TC)
				{
					iRet = 0;
				}
				else // (ucACType == AC_AAC)
				{
					iRet = EMV_DENIAL;
				}
			}
		}

		break;
	case CLSS_VISA_WAVE2:
		if (ucACType == AC_TC)
		{
			Clss_DelAllRevocList_Wave();
			Clss_DelAllCAPK_Wave();

			if ( Clss_GetTLVData_Wave(0x8F, &ucPkIndex,  &iTempLen) == 0)
			{
				//if (AppConv_GetTLVData(0x9F06, aucAid, &nTempLen) == 0)
				{
					AppSetClss_capk(ucPkIndex, sg_aucFinalAID, sg_ucAppType);
					AppSetClss_RevLst(ucPkIndex, sg_aucFinalAID, sg_ucAppType);
				}
			}
			// internal authenticate, offline approval
			iRet = Clss_CardAuth_Wave(&ucACType, &ucDDAFailFlg);
#ifdef DEBUG_
		AppLog("Clss_CardAuth_Wave = %d ", iRet);
#endif
			if (iRet)
			{
				return EMV_DENIAL; // 0424-3
			}
		}
		AppRemovePicc();


		break;
	default:
		//AppRemovePicc(PICC_LED_NONE);
		iRet = CLSS_TERMINATE;
		break;
	}

	if (iRet == 0)
	{
		AppSetTransACType(ucACType);
	}
	return iRet;
}

static int AppTransProc_MC(uchar ucTransPath, uchar *pucACType)
{
	int iRet=0,nTempLen=0;
	uchar ucPkIndex,aucAid[17]={0};
	CLSS_TORN_LOG_RECORD atAppTornTransLog[5];//Torn Transaction Log
	int nAppTornLogNum = 0;//number of Tornlog
	int nUpdatedFlg = 0;

	if (ucTransPath == CLSS_MC_MCHIP) // 0x06)
	{
		Clss_DelAllRevocList_MC_MChip();
		Clss_DelAllCAPK_MC_MChip();

		if (Clss_GetTLVDataList_MC((uchar*)"\x8F", 1, 1, &ucPkIndex, (uint *)&nTempLen) == 0)
		{
			if (Clss_GetTLVDataList_MC((uchar*)"\x4F", 1, sizeof(aucAid), aucAid, (uint *)&nTempLen) == 0)
			{

				AppSetClss_capk(ucPkIndex, aucAid, sg_ucAppType);// CAPK [1/4/2015 jiangjy]
				AppSetClss_RevLst(ucPkIndex, aucAid, sg_ucAppType);
			}
		}

		AppGetTornLog_MC(atAppTornTransLog, &nAppTornLogNum);
		if (nAppTornLogNum)
		{
			Clss_SetTornLog_MC_MChip(atAppTornTransLog, nAppTornLogNum);
		}
		iRet = Clss_TransProc_MC_MChip(pucACType);
#ifdef DEBUG_
		AppLog("Clss_TransProc_MC_MChip = %d ", iRet);
#endif
		memset(atAppTornTransLog, 0, sizeof(atAppTornTransLog));
		nAppTornLogNum = 0;
		nUpdatedFlg = 0;
		Clss_GetTornLog_MC_MChip(atAppTornTransLog, &nAppTornLogNum, &nUpdatedFlg);
		if (nUpdatedFlg)
		{
			AppSaveTornLog_MC(atAppTornTransLog, nAppTornLogNum);
		}
	}
	else if (ucTransPath == CLSS_MC_MAG) // 0x05)
	{
		iRet = Clss_TransProc_MC_Mag(pucACType);
#ifdef DEBUG_
		AppLog("Clss_TransProc_MC_Mag = %d ", iRet);
#endif
	}
	else
	{
		iRet = CLSS_TERMINATE;
	}

	if (iRet != ICC_CMD_ERR)//3G10-9301(Trx1_CCC_Res) 3G10-9300(Trx2_CCC_Res)
	{
		AppRemovePicc();//AppRemovePicc(PICC_LED_GREEN);
		Inter_DisplayMsg(MSG_CARD_READ_OK);
	}
	if (iRet)
	{
		return iRet;
	}

	AppSetTransACType(*pucACType);

	return EMV_OK;
}

static int ClssProcFlow_VISA(uchar *pucFinalData, int iFinalDataLen, Clss_PreProcInterInfo tClssProcInterInfo)
{
#ifdef CLSS_DEBUG
Clss_SetDebug_Wave(1);
#endif

	int iRet=0;
	uchar ucAcType=0, ucPathType=0, ucTemp[100]={0};

	ClssBaseParameterSet_WAVE();
	SetFinalSelectAID(pucFinalData+1, pucFinalData[0]);
	iRet = Clss_SetFinalSelectData_Wave(pucFinalData, iFinalDataLen);
#ifdef DEBUG_
		AppLog("[ClssProcFlow_VISA] Clss_SetFinalSelectData_Wave = %d ", iRet);
#endif
	if( iRet != EMV_OK ) {
		return iRet;
	}

	//added by Gillian Chen 2015/9/25
	iRet = Clss_SetTLVData_Wave(0x9F5A, "123", 10);
#ifdef DEBUG_
		AppLog("[ClssProcFlow_VISA] Clss_SetTLVData_Wave = %d ", iRet);
#endif
	if( sg_ucDRLSupportFlg == 1 ) {
		iRet = Clss_GetTLVData_Wave(0x9F5A, sg_aucProID, &sg_iProIDLen);
#ifdef DEBUG_
		AppLog("[ClssProcFlow_VISA] Clss_GetTLVData_Wave = %d ", iRet);
#endif
		if ( iRet == EMV_OK ) {
			iRet = AppFindMatchProID(sg_aucProID, sg_iProIDLen);
#ifdef DEBUG_
		AppLog("[ClssProcFlow_VISA] AppFindMatchProID = %d ", iRet);
#endif
			if ( iRet == EMV_OK ) {
				iRet = Clss_SetDRLParam_Wave(sg_tProgInfo);
#ifdef DEBUG_
		AppLog("[ClssProcFlow_VISA] Clss_SetDRLParam_Wave = %d ", iRet);
#endif
				if ( iRet != EMV_OK) {
					return iRet;
				}
			}
			else {
				return iRet;
			}
		}
		else {
			return iRet;
		}
	}
	iRet = Clss_SetTransData_Wave(&sg_tClssTransParam, &tClssProcInterInfo);
#ifdef DEBUG_
		AppLog("[ClssProcFlow_VISA] Clss_SetTransData_Wave = %d ", iRet);
#endif
	if ( iRet != EMV_OK ) {
		return iRet;
	}

	ucAcType = 0;
	memset(ucTemp, 0, sizeof(ucTemp));
	iRet = Clss_Proctrans_Wave(ucTemp, &ucAcType);
#ifdef DEBUG_
		AppLog("[ClssProcFlow_VISA] Clss_Proctrans_Wave = %d ", iRet);
#endif
	if ( iRet ){
		if ( iRet == CLSS_RESELECT_APP ) {
			iRet = Clss_DelCurCandApp_Entry();
			if ( iRet ) {
				return iRet;
			}
			return iRet;
		}
		//see phone
		else if ( (iRet == CLSS_REFER_CONSUMER_DEVICE) && ((tClssProcInterInfo.aucReaderTTQ[0] & 0x20) == 0x20) ) {
			Inter_DisplayMsg(MSG_SEE_PHONE);
			iRet= App_Try_Again;
			DelayMs(1200);
			return iRet;
		}
		else if ( iRet == CLSS_USE_CONTACT ) {
			Inter_DisplayMsg(MSG_TRY_ANOTHER_INTERFACE);
			return CLSS_USE_CONTACT;
		}
		else {
			return iRet;
		}
	}

	ucPathType = ucTemp[0];
	AppSetTransPath(ucPathType);

	iRet = AppTransProc_VISA(ucPathType, ucAcType);
#ifdef DEBUG_
		AppLog("[ClssProcFlow_VISA] AppTransProc_VISA = %d ", iRet);
#endif

	return iRet;
}

static int ClssProcFlow_MC(uchar *pucFinalData, int iFinalDataLen, Clss_PreProcInterInfo tClssProcInterInfo)
{
#ifdef CLSS_DEBUG
Clss_SetDebug_MC(1);
#endif
	int iRet=0;
	uchar ucAcType=0, ucPathType=0;

	Clss_SetCBFun_SendTransDataOutput_MC(ClssSendTransDataOutput_MC);
	SetFinalSelectAID(pucFinalData+1, pucFinalData[0]);
	//removed by Kevin Liu, new version library need to set data after Clss_SetFinalSelectData_MC.
	//ClssTermParamSet_MC();
	AppLoadTornLog_MC();	//added by Kevin Liu 20160728
	iRet = Clss_SetFinalSelectData_MC(pucFinalData, iFinalDataLen);
#ifdef DEBUG_
	AppLog("Clss_SetFinalSelectData_MC = %d ", iRet);
#endif
	//the return code is not EMV_OK, Application should get DF8129). [12/29/2014 jiangjy]
	if ( iRet == CLSS_RESELECT_APP ) {
		iRet = Clss_DelCurCandApp_Entry();
		if ( iRet != 0 ) {
			InitPaymentData();
			sg_aucUserInterReqData[0]=MI_ERROR_OTHER_CARD;
			sg_aucUserInterReqData[1]=MI_NOT_READY;
			memcpy(sg_aucUserInterReqData+2, MSG_HOLD_TIME_VALUE, 3);

			sg_aucErrIndication[5]=MI_ERROR_OTHER_CARD;
			sg_aucErrIndication[1] = L2_EMPTY_CANDIDATE_LIST;//S51.11
			sg_aucOutcomeParamSet[0] = OC_END_APPLICATION;
			sg_tDiscretionayData.ucErrIndicFlg = 1;
			//					nSendTransDataOutput_MC(T_UIRD | T_OCPS | T_DISD);//S51.11 S51.12
//			return ERR_TRAN_FAIL;
			return iRet;
		}
		return iRet;
	}
	else if ( iRet ) {
		return iRet;
	}
	//added by Kevin Liu, new version library need to set data after Clss_SetFinalSelectData_MC.
	ClssTermParamSet_MC();
	iRet = Clss_InitiateApp_MC();
#ifdef DEBUG_
	AppLog("Clss_InitiateApp_MC = %d ", iRet);
#endif
	//the return code is not EMV_OK, Application should get DF8129)
	if ( iRet == CLSS_RESELECT_APP ) {
		iRet = Clss_DelCurCandApp_Entry();
		if ( iRet ) {
			InitPaymentData();// paypass 3.0.1 by zhoujie
			sg_aucUserInterReqData[0]=MI_ERROR_OTHER_CARD;//S51.11 for paypass 3.0.1 by zhoujie
			sg_aucUserInterReqData[1]=MI_NOT_READY;
			memcpy(sg_aucUserInterReqData+2, MSG_HOLD_TIME_VALUE, 3);

			sg_aucErrIndication[5]=MI_ERROR_OTHER_CARD;
			sg_aucErrIndication[1] = L2_EMPTY_CANDIDATE_LIST;//S51.11
			sg_aucOutcomeParamSet[0] = OC_END_APPLICATION;
			sg_tDiscretionayData.ucErrIndicFlg = 1;
			//					nSendTransDataOutput_MC(T_UIRD | T_OCPS | T_DISD);//S51.11 S51.12
//			return ERR_TRAN_FAIL;
			return iRet;
		}
		return iRet;
	}
	else if ( iRet ) {
		return iRet;
	}
	ucPathType = 0;
	iRet = Clss_ReadData_MC(&ucPathType);
#ifdef DEBUG_
	AppLog("Clss_ReadData_MC = %d ", iRet);
#endif
	//f the return code is not EMV_OK, Application should get DF8129)
	if ( iRet ) {
		if ( iRet == CLSS_RESELECT_APP ) {
			iRet = Clss_DelCurCandApp_Entry();
			if ( iRet ) {
				InitPaymentData();
				sg_aucUserInterReqData[0]=MI_ERROR_OTHER_CARD;
				sg_aucUserInterReqData[1]=MI_NOT_READY;
				memcpy(sg_aucUserInterReqData+2, MSG_HOLD_TIME_VALUE, 3);

				sg_aucErrIndication[5]=MI_ERROR_OTHER_CARD;
				sg_aucErrIndication[1] = L2_EMPTY_CANDIDATE_LIST;//S51.11
				sg_aucOutcomeParamSet[0] = OC_END_APPLICATION;
				sg_tDiscretionayData.ucErrIndicFlg = 1;

				return iRet;
			}
			return iRet;
		}
		else {
			return iRet;
		}
	}

	AppSetTransPath(ucPathType);

	iRet = AppTransProc_MC(ucPathType, &ucAcType);
#ifdef DEBUG_
	AppLog("AppTransProc_MC = %d ", iRet);
#endif
	if ( sg_aucUserInterReqData[0] == MI_SEE_PHONE ) {
		Inter_DisplayMsg(MSG_SEE_PHONE);
	}
	if ( (sg_aucOutcomeParamSet[0] == OC_TRY_AGAIN) || (sg_aucOutcomeParamSet[1] != OC_NA) ) {
		iRet = App_Try_Again;
	}

	return iRet;
}

static int ClssProcFlow_ALL(void)
{
	int	 iRet=0, iLen=0;
	unsigned char ucTemp[300]={0}, ucKernType=0;
	Clss_PreProcInterInfo tClssProcInterInfo;

	Clss_SetMCVersion_Entry(3);
	//app select
	iRet = Clss_AppSlt_Entry(0,0);
#ifdef DEBUG_
	AppLog("Clss_AppSlt_Entry = %d ", iRet);
#endif
	//returns	EMV_OK	CLSS_PARAM_ERR	ICC_CMD_ERR	ICC_BLOCK	EMV_NO_APP	EMV_APP_BLOCK	EMV_NO_APP_PPSE_ERR
	if ( iRet != EMV_OK ) {
		AppCreateOutcomeData_MC(iRet);
		return iRet;
	}

	while ( 1 ) {
		AppInitPaymentData_MC();
		iLen = 0;
		ucKernType = 0;
		memset(ucTemp, 0, sizeof(ucTemp));
		iRet = Clss_FinalSelect_Entry(&ucKernType, ucTemp, &iLen);
#ifdef DEBUG_
		AppLog("Clss_FinalSelect_Entry = %d ", iRet);
#endif
		//returns	EMV_OK	CLSS_PARAM_ERR	ICC_CMD_ERR	EMV_RSP_ERR	EMV_NO_APP	EMV_APP_BLOCK	ICC_BLOCK
		//CLSS_USE_CONTACT	EMV_DATA_ERR	CLSS_RESELECT_APP
		if( iRet != EMV_OK ) {
			return iRet;
		}
		//VISA MASTERCARD
		if ( (ucKernType != KERNTYPE_VIS) && (ucKernType != KERNTYPE_MC) ) {
			return TRANS_EMV_NO_APP;
		}

		//get pre-process data
		memset(&tClssProcInterInfo, 0, sizeof(Clss_PreProcInterInfo));
		iRet = Clss_GetPreProcInterFlg_Entry(&tClssProcInterInfo);
#ifdef DEBUG_
		AppLog("Clss_GetPreProcInterFlg_Entry = %d ", iRet);
#endif
		//returns	EMV_OK	CLSS_PARAM_ERR	CLSS_USE_CONTACT
		if ( iRet != EMV_OK ) {
			return iRet;
		}

		iLen = 0;
		memset(ucTemp, 0, sizeof(ucTemp));
		iRet = Clss_GetFinalSelectData_Entry(ucTemp, &iLen);
#ifdef DEBUG_
		AppLog("Clss_GetFinalSelectData_Entry = %d ", iRet);
#endif
		//returns	EMV_OK	CLSS_PARAM_ERR
		if ( iRet != EMV_OK ) {
			return iRet;
		}

		iRet = AppSetCurAppType(ucKernType);
		switch ( AppGetAppType() ) {
		case KERNTYPE_VIS:
			iRet = ClssProcFlow_VISA(ucTemp, iLen, tClssProcInterInfo);
#ifdef DEBUG_
		AppLog("ClssProcFlow_VISA = %d ", iRet);
#endif
			break;
		case KERNTYPE_MC:
			iRet = ClssProcFlow_MC(ucTemp, iLen, tClssProcInterInfo);
#ifdef DEBUG_
		AppLog("ClssProcFlow_MC = %d ", iRet);
#endif
			break;
		default:
			break;
		}
		if ( iRet == EMV_OK ) {
			break;
		}
		else if ( iRet == CLSS_RESELECT_APP ) {
			continue;
		}
		else {
            AppRemovePicc();
			break;
		}
	}
	return iRet;
}

static int AppConv_CreateOutCome(int nRet, uchar ucACType, CLSS_OUTCOME_DATA *pstOutComeData)
{
	uchar aucOutcomeParamSet[8] = {0};
	uchar ucCVMType = 0;
	uint unLen=0;
	
	if(pstOutComeData == NULL)
	{
		return EMV_PARAM_ERR;
	}
	memset(pstOutComeData, 0, sizeof(CLSS_OUTCOME_DATA));
	pstOutComeData->unPathType = AppGetTransPath();
	switch (AppGetAppType())
	{
	case KERNTYPE_VIS:
		if (!nRet)
		{
			nRet = Clss_GetCvmType_Wave(&pstOutComeData->ucCVMType);//  [1/22/2015 jiangjy]
			if (nRet)
			{
				pstOutComeData->ucTransRet = CLSS_DECLINED;
			}
			else
			{
				if(ucACType == AC_TC)
				{
					pstOutComeData->ucTransRet = CLSS_APPROVE;
				}
				else if(ucACType == AC_ARQC)//AC_ARQC
				{
					pstOutComeData->ucTransRet = CLSS_ONLINE_REQUEST;
				}
				else
				{
					pstOutComeData->ucTransRet = CLSS_DECLINED;
				}
			}

		}
		else if (nRet == EMV_DENIAL || nRet == CLSS_DECLINE)
		{
			pstOutComeData->ucTransRet = CLSS_DECLINED;
		}
		else if (nRet == CLSS_USE_CONTACT)
		{
			pstOutComeData->ucTransRet = CLSS_TRY_ANOTHER_INTERFACE;
		}
		else
		{
			pstOutComeData->ucTransRet = CLSS_END_APPLICATION;
		}
		break;
	case KERNTYPE_MC:
		memset(aucOutcomeParamSet, 0, sizeof(aucOutcomeParamSet));
		Clss_GetTLVDataList_MC("\xDF\x81\x29", 3, sizeof(aucOutcomeParamSet), aucOutcomeParamSet, &unLen);
		switch(aucOutcomeParamSet[0] & 0xF0)
		{
		case CLSS_OC_APPROVED:
			pstOutComeData->ucTransRet = CLSS_APPROVE;
			break;
		case CLSS_OC_DECLINED:
			pstOutComeData->ucTransRet = CLSS_DECLINED;
			break;
		case CLSS_OC_ONLINE_REQUEST:
			pstOutComeData->ucTransRet = CLSS_ONLINE_REQUEST;
			break;
		case CLSS_OC_TRY_ANOTHER_INTERFACE:
			pstOutComeData->ucTransRet = CLSS_TRY_ANOTHER_INTERFACE;
			break;
		default://CLSS_OC_END_APPLICATION
			pstOutComeData->ucTransRet = CLSS_END_APPLICATION;
			break;
		}
		switch(aucOutcomeParamSet[3]&0xF0)
		{
		case CLSS_OC_NO_CVM:
			pstOutComeData->ucCVMType = CLSS_CVM_NO;
			break;
		case CLSS_OC_OBTAIN_SIGNATURE:
			pstOutComeData->ucCVMType = CLSS_CVM_SIG;
			break;
		case CLSS_OC_ONLINE_PIN:
			pstOutComeData->ucCVMType = CLSS_CVM_ONLINE_PIN;
			break;
		case CLSS_OC_CONFIRM_CODE_VER:
			pstOutComeData->ucCVMType = CLSS_CVM_OFFLINE_PIN;
			break;
		default:
			pstOutComeData->ucCVMType = CLSS_CVM_NO;
			break;
		}
		break;
	default:
		break;
	}
	return nRet;

}

int ClssCompleteTrans(void)
{
	int iRet = 0;
	unsigned char ucKernelType = 0, aucRspCode[3] = {0}, ucOnlineResult = 0;
	unsigned char aucAuthCode[7] = {0};
	int iAuthDataLen=0, iIssuerScriptLen=0;

	ucKernelType = AppGetAppType();
	ucOnlineResult = g_tTransParam.ucOnlineResult;
	memcpy(aucRspCode, g_tTransParam.ucRspCode, 2);
	memcpy(aucAuthCode, g_tTransParam.ucAuthCode, 6);
	iAuthDataLen = g_tTransParam.ucAuthDataLen[0] * 256 + g_tTransParam.ucAuthDataLen[1];
	iIssuerScriptLen = g_tTransParam.ucIssuerScriptLen[0] * 256 + g_tTransParam.ucIssuerScriptLen[1];

	if( (iAuthDataLen == 0) || (iIssuerScriptLen == 0) ) {
		return EMV_OK;
	}

	iRet = ClssDetectTapCard();
 	if ( iRet ) {
		return iRet;
	}

	if ( ucKernelType == KERNTYPE_VIS ) {
		iRet = ClssCompleteTrans_WAVE(ucOnlineResult, aucRspCode, aucAuthCode, 
			g_tTransParam.ucAuthData, iAuthDataLen, g_tTransParam.ucIssuerScript, iIssuerScriptLen);
	}

	AppRemovePicc();

	if ( iRet ) {
		Inter_DisplayMsg(MSG_DECLINED);
		return iRet;
	}
	Inter_DisplayMsg(MSG_APPROVED);
	return EMV_OK;
}


static int ClssCompleteTrans_WAVE(uchar ucInOnlineResult, uchar aucRspCode[], uchar aucAuthCode[], uchar aucIAuthData[], int nIAuthDataLen,  uchar aucScript[], int nScriptLen)
{
	uchar aucBuff[256] = {0};
	uchar aucCTQ[32] = {0};
	int iCTQLen = 0, iLen = 0, iRet = 0;
	uchar ucKernType = 0;

	if ( (nIAuthDataLen == 0) && (nScriptLen == 0) ) {
		return EMV_NO_DATA;
	}

	if ( ucInOnlineResult != 0x00 ) {
		return -1;
	}

	memset(aucCTQ, 0, sizeof(aucCTQ));
	//TODO get TTQ
	if (/*(g_tClssPreProcInfoIn.aucReaderTTQ[2] & 0x80) == 0x80
		&& */Clss_GetTLVData_Wave(0x9F6C, aucCTQ, &iCTQLen) == 0
		&& (aucCTQ[1] & 0x40) == 0x40)
	{
        memset(aucBuff, 0, sizeof(aucBuff));
        iRet = Clss_FinalSelect_Entry(&ucKernType, aucBuff, &iLen);
        if (iRet != 0)
        {
            return iRet;
        }

        iRet = Clss_IssuerAuth_Wave(aucIAuthData, nIAuthDataLen);
        if(iRet)
        {
            return iRet;
        }
        iRet = Clss_IssScriptProc_Wave(aucScript, nScriptLen);
        if(iRet)
        {
            return iRet;
        }
	}
	return EMV_OK;
}

int ClssDetectTapCard(void)
{
	int iRet = 0, iTime = 0;
	uchar ucKey = 0;

	//tap card
	iRet = PiccOpen();
	if(iRet != 0)
	{
		ScrCls();
		PubDispString("OPEN PICC ERR", 0|DISP_LINE_LEFT);
		// ==== Modified by ZhangYuan 2016-10-17 ======
	//	getkey();	
		PubWaitKey(10);
		// ==== end ==============================

		return iRet;
	}
	TimerSet(3,500);
	kbflush();
	while(1)
	{
		iTime = TimerCheck(3);
		if(!iTime)
		{
			return -1;
		}

		if(kbhit() != NOKEY)
		{
			ucKey = getkey();
			if(ucKey == KEYCANCEL)
			{
				return EMV_USER_CANCEL;
			}
		}
		else	//modified by kevinliu 2015/12/09 It's hard to cancel before modified.
		{
			iRet = PiccDetect(0, NULL, NULL, NULL, NULL);
			if(iRet == 0)
			    break;
			else if(iRet == 3|| iRet==5 || iRet==6)
			{
				DelayMs(100);
				continue;
			}
			else if(iRet == 4)
			{
				ScrCls();
				PubDispString("TOO MANY CARDS", 0|DISP_LINE_LEFT);
				// ==== Modified by ZhangYuan 2016-10-17 ======
			//	getkey();	
				Beep();
				DelayMs(100);
				// ==== end ==============================
				return -1;
			}
			else// if(iRet == 1 || iRet==2)
            {
                return -1;
            }
		}
	}
	return 0;
}


//EMV contactless card process
int ClssStartTransaction(void)
{
	int iRet=0;
	unsigned char ucAcType=0;
	unsigned char ucTmp[64]={0};

	ClssTransInit();

	//prepare transaction parameter
	iRet = ClssPreProcTxnParam();
#ifdef DEBUG_
	AppLog("ClssPreProcTxnParam = %d ", iRet);
#endif
	if ( iRet != EMV_OK ) {
		return iRet;
	}

	while ( 1 ) {
		//contactless transaction flow
		iRet = ClssProcFlow_ALL();
#ifdef DEBUG_
		AppLog("ClssProcFlow_ALL = %d ", iRet);
#endif
		if ( iRet )
		{
			if ( iRet == App_Try_Again ) {
				DelayMs(1200);
				continue;
			}
			PiccClose();
			return iRet;
		}

		ucAcType = AppGetTransACType();

		//AC TYPE
        if ( (iRet == 0) && (AppGetTransACType() == AC_AAC)
                && (AppGetAppType() == KERNTYPE_VIS) ) {
            iRet = EMV_DENIAL;
        }
		//create output
		iRet = AppConv_CreateOutCome(iRet, ucAcType, &sg_tOutComeData);
#ifdef DEBUG_
		AppLog("AppConv_CreateOutCome = %d ", iRet);
#endif
		if ( iRet ) {
			if ( iRet == App_Try_Again ) {
				DelayMs(1200);
				continue;
			}
			PiccClose();
			return iRet;
		}
		else {
			break;
		}
	}

	memset(ucTmp, 0, sizeof(ucTmp));
	sprintf(ucTmp, "AC = %02x", sg_tOutComeData.ucTransRet);
	ScrCls();
	PubDispString(ucTmp, 0|DISP_LINE_LEFT);
	// ==== Modified by ZhangYuan 2016-10-17 ======
//	getkey();	
//	PubWaitKey(5);
	DelayMs(300);
	// ==== end ==============================

	memset(ucTmp, 0, sizeof(ucTmp));
	sprintf(ucTmp, "CVM = %02x", sg_tOutComeData.ucCVMType);
	ScrCls();
	PubDispString(ucTmp, 0|DISP_LINE_LEFT);
	// ==== Modified by ZhangYuan 2016-10-17 ======
//	getkey();	
//	PubWaitKey(5);
	DelayMs(300);
	// ==== end ==============================


	memset(ucTmp, 0, sizeof(ucTmp));
	sprintf(ucTmp, "PATH = %02x", sg_tOutComeData.unPathType);
	ScrCls();
	PubDispString(ucTmp, 0|DISP_LINE_LEFT);
	// ==== Modified by ZhangYuan 2016-10-17 ======
//	getkey();	
//	PubWaitKey(5);
	DelayMs(300);
	// ==== end ==============================
	
	return EMV_OK;
}

#endif   //#ifndef _WIN32
